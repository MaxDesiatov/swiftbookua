### Колекції протоколів

Протокол можу використовуватись як тип, і в тому числі зберігатись у колекції на кшталт масиву чи словнику, як зазначено в [Протоколи як типи](#Protocols-as-Types). У наступному прикладі створюється масив з трьох речей, підпорядкованих протоколу `TextRepresentable`:

```swift
let things: [TextRepresentable] = [game, d12, simonTheHamster]
```

Тепер можливо проітерувати елементи цього масиву, і надрукувати текстовий опис кожного елементу:

```swift
for thing in things {
    print(thing.textualDescription)
}
// Гра "Ліла" на 25 клітинок
// 12-стороння гральна кість
// Хом'як на ім'я Сомко
```

Слід зазначити, що константа `thing` має тип `TextRepresentable`. Її тип не `Dice`, не `DiceGame`, і не `Hamster`, навіть якщо фактичний екземпляр за лаштунками має один з цих типів. З усім тим, оскільки вона має тип `TextRepresentable`, а всі підпорядковані цьому протоколу типи мають властивість `textualDescription`, можна безпечно звертатись до `thing.textualDescription` в кожній ітерації циклу.

### Наслідування протоколів

Протокол може _наслідувати_ один або декілька інших протоколів, і додавати подальші вимоги поверх успадкованих вимог. Синтаксис наслідування протоколів є аналогічним синтаксису наслідування класів, але з можливістю перечислити декілька успадкованих протоколів, розділяючи їх комами:

```swift
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // тут йде визначення протоколу
}
```

Ось приклад протоколу, що наслідує вищезазначений протокол `TextRepresentable`:

```swift
protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}
```

У цьому прикладі визначено новий протокол на ім'я `PrettyTextRepresentable`, котрий наслідує протокол `TextRepresentable`. Всі типи, що підпорядковуються протоколу `PrettyTextRepresentable`, повинні задовольняти усім вимогам, що визначає протокол `TextRepresentable`, _плюс_ усім додатковим вимогам, що визначає протокол `PrettyTextRepresentable`. У цьому прикладі, протокол `PrettyTextRepresentable` додає єдину вимогу: мати властивість для читання на ім'я `prettyTextualDescription`, що повертає тип `String`.

Клас `SnakesAndLadders` можна розширити для підпорядкування його протоколу `PrettyTextRepresentable`:

```swift
extension SnakesAndLadders: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder > 0:
                output += "▲ "
            case let snake where snake < 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
```

Це розширення підпорядковує клас `SnakesAndLadders` до протоколу `PrettyTextRepresentable`, і надає реалізацію властивості `prettyTextualDescription`. Будь-що, підпорядковане протоколу `PrettyTextRepresentable`, має бути також підпорядкованим протоколу `TextRepresentable`, і тому реалізація властивості `prettyTextualDescription` починається зі звернення до властивості `textualDescription` з протоколу `TextRepresentable`, щоб створити початковий рядок `output`. До цього рядка додається двокрапка та перехід на новий рядок \(`":\n"`\), і цей рядок є початковим у формуванні гарного текстового представлення. Після цього йде ітерування масиву клітинок на дошці, і додаються символи, що представляють вміст кожної клітинки:

Якщо значення клітинки більше нуля, ця клітинка представляє основу сходів, і представляється символом ▲.  
Якщо значення клітинки менше нуля, ця клітинка представляє голову змії, і представляється символом ▼.  
В інших випадках, значення клітинки дорівнює нулю, ця клітинка є вільною і представляється символом ○.

Властивість `prettyTextualDescription` тепер можна використовувати для друку гарного опису будь-якого екземпляру класу `SnakesAndLadders`:

```swift
print(game.prettyTextualDescription)
// Гра "Ліла" на 25 клітинок:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
```

### Протоколи лише для класів

Можна зробити протокол доступним для підпорядкування лише класів \(а не структур чи перечислень\), додавши протокол `AnyObject` до списку наслідування протоколу.

```swift
protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // тут йде визначення протоколи лише для класів
}
```

У прикладі вище, протоколу `SomeClassOnlyProtocol` можна підпорядковувати лише класи. Якщо спробувати підпорядкувати йому структуру чи перечислення, виникне помилка часу компіляції.

> **Примітка**
>
> Слід використовувати протоколи лише для класів тоді, коли поведінка, що визначається вимогами протоколу, передбачає, що підпорядкований тип має семантику типу-посилання, а не типу значення. Детальніше з семантикою типів-значень та типів-посилань можна ознайомитись у підрозділах  [Структури і перечислення як типи-значення](8_classes_and_structures.md#Структури-і-перечислення-як-типи-значення) та [Класи як типи-посилання](8_classes_and_structures.md#Класи-як-типи-посилання).

### Композиція протоколів

Іноді буває потрібно вимагати підпорядкування типу кільком протоколам одночасно. Для цього можна скомбінувати кілька протоколів у єдину вимогу за допомогою _композиції протоколів_. Композиції протоколів поводяться так, ніби було оголошено тимчасовий локальний протокол, що об'єднує у собі вимоги усіх протоколів у композиції. Композиції протоколів, утім, не визначають жодних нових протоколів.

Композиції протоколів записуються у формі `SomeProtocol & AnotherProtocol`. Можна перечислити будь-яку необхідну кількість протоколів, розділяючи їх амперсандами \(`&`\). Окрім списку протоколів, композиція протоколів може містити один клас: таким чином можна висловити вимогу бути нащадком цього класу.

Ось приклад, в якому комбінуються два протоколи, що називаються `Named` та `Aged`, в єдину композицію протоколів, котра використовується як параметр функції:

```swift
protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(to celebrator: Named & Aged) {
    print("З Днем Народження, \(celebrator.name), вам \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Максим", age: 21)
wishHappyBirthday(to: birthdayPerson)
// Надрукує "З Днем Народження, Максим, вам 21!"
```

У цьому прикладі, протокол `Named` має єдину вимогу властивості для читання типу `String` на ім'я `name`. Протокол `Aged` має єдину вимогу властивості для читання типу `Int` на ім'я `age`. Структура `Person` представляє дані про особу, і підпорядковується обом цим протоколам.

У прикладі також визначено функцію `wishHappyBirthday(to:)`, що друкує вітання з днем народження. Параметр `celebrator` цієї функції має тип `Named & Aged`, що значить “будь-який тип, що підпорядковується протоколам `Named` та `Aged` одночасно”. Не має значення, який саме тип передати до функції, головне, щоб він був підпорядкованим обом цим протоколам.

У прикладі далі створюється новий екземпляр `Person`, що називається `birthdayPerson`, і цей новий екземпляр передається до функції `wishHappyBirthday(to:)`. Оскільки структура `Person` підпорядкована обом протоколам, цей виклик є коректним, і функція `wishHappyBirthday(to:)` друкує привітання з днем народження.

Ось приклад, в якому протокол `Named` з попереднього прикладу комбінується із класом `Location`:

```swift
class Location {
    var latitude: Double
    var longitude: Double
    init(latitude: Double, longitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
    }
}
class City: Location, Named {
    var name: String
    init(name: String, latitude: Double, longitude: Double) {
        self.name = name
        super.init(latitude: latitude, longitude: longitude)
    }
}
func beginConcert(in location: Location & Named) {
    print("Привіт, \(location.name)!")
}

let seattle = City(name: "Славутич", latitude: 47.6, longitude: -122.3)
beginConcert(in: seattle)
// Надрукує "Привіт, Славутич!"
```

Функція `beginConcert(in:)` приймає параметр типу `Location & Named`, що означає “будь-який клас-нащадок класу `Location`, що підпорядковується до протоколу `Named`”. В даному випадку, клас `City` задовольняє обом цим вимогам.

Передача екземпляру `birthdayPerson` до функції `beginConcert(in:)` є некоректним, оскільки `Person` не є класом-нащадком класу `Location`. Так само, якщо створити клас-нащадок класу `Location`, що не підпорядковується протоколу `Named`, виклик функції `beginConcert(in:)` з екземпляром цього класу буде також некоректним.

### Перевірка на підпорядкованість протоколу

Щоб перевірити тип на підпорядкованість протоколу, або привести тип до певного протоколу, можна використовувати описані в розділі [Приведення типів](17_type_casting.md) оператори `is` та `as`. Перевірка на підпорядкованість та приведення до протоколу має точно такий же синтаксис, що й перевірка на тип чи приведення до типу:

* Оператор `is` повертає `true`, якщо екземпляр підпорядкований до протоколу, і повертає `false`, якщо не підпорядкований.
* Версія `as?` оператору приведення типу повертає опціональне значення типу протоколу, і це значення дорівнює `nil` у випадках, коли тип не підпорядкований до протоколу.
* Версія `as!` оператору приведення типу примусово приводить до типу протоколу, і призводить до помилки часу виконання, якщо приведення невдале.

У цьому прикладі визначено протокол, що називається `HasArea`, що представляє будь-що, що має площу, з єдиною вимогою властивості для читання типу `Double` на ім'я `area` \(що й виражає площу\):

```swift
protocol HasArea {
    var area: Double { get }
}
```

Ось два класи, `Circle` та `Country`, що моделюють коло та країну відповідно, обидва підпорядковані протоколу `HasArea`:

```swift
class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
```

Клас `Circle` реалізовує вимогу властивості `area` за допомогою властивості, що обчислюється, базуючись на властивості `radius`, що зберігається. Клас `Country`реалізовує вимогу властивості `area` прямо, за допомогою властивості, що зберігається. Обидва класи коректно підпорядковуються до протоколу `HasArea`.

Ось клас `Animal`, що моделює тварину і не підпорядковується протоколу `HasArea`:

```swift
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
```

Класи `Circle`, `Country` та `Animal` не мають спільного базового класу. Разом з тим, всі вони є класами, і тому екземпляри усіх цих трьох типів можуть бути використані для ініціалізації масиву, що зберігає значення типу `AnyObject`:

```swift
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 603_628),
    Animal(legs: 4)
]
```

Цей масив `objects` було ініціалізовано за допомогою літералу масиву, що містить екземпляр `Circle` з радіусом у 2 одиниці, екземпляр `Country`, ініціалізований площею України у квадратних кілометрах, та екземпляр `Animal`, що представляє тварину з чотирма лапами.

Тепер масив `objects` можна проітерувати, і кожен об'єкт у масиві можна перевірити на підпорядкованість протоколу `HasArea`:

```swift
for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Площа дорівнює \(objectWithArea.area)")
    } else {
        print("Щось, що не має площі")
    }
}
// Площа дорівнює 12.5663708
// Площа дорівнює 603628.0
// Щось, що не має площі
```

Для кожного об'єкту в масиві, що підпорядкований протоколу `HasArea`, оператор `as?` поверне опціональне значення, що буде розгорнуте за допомогою прив'язування опціоналу у константу на ім'я `objectWithArea`. Константа `objectWithArea` має тип `HasArea`, тому можна у типобезпечний спосіб звертатись до її властивості `area` та друкувати її значення.

Слід помітити, що об'єкти за лаштунками не змінюються внаслідок процесу приведення типів. Вони продовжують бути екземплярами `Circle`, `Country` та `Animal`. Однак, про посилання на один з них у константі `objectWithArea` відомо лише те, що воно має тип `HasArea`, і тому можна звертатись лише до властивостей цього типу.

### Опціональні вимоги протоколів

Протокол може визначати _опціональні вимоги_. Ці вимоги не обов'язково повинні бути реалізованими підпорядкованими до протоколу типами. Опціональні вимоги позначаються модифікатором `optional` в оголошенні протоколу. Опціональні вимоги у Swift присутні головним чином через необхідність взаємодії з кодом на Objective-C. Тому як протокол, так і опціональні вимоги в ньому повинні також позначатись атрибутом `@objc`. Слід зазначити, що протоколам, позначеним атрибутом `@objc`, можуть підпорядковуватись лише класи, успадковані від класів Objective-C чи інших класів, позначених модифікатором `@objc`. Таким протоколам не можна підпорядкувати структуру чи перечислення.

При створенні опціональних вимог методів чи властивостей, їх тип автоматично стає опціональним. Наприклад, метод типу `(Int) -> String` стає методом типу `((Int) -> String)?`. Варто помітити, що опціональним стає тип самого методу, а не тип, що повертає цей метод.

До опціональної вимоги протоколу можна звертатись за допомогою ланцюжка опціоналів, щоб врахувати можливість, що вимогу не було реалізовано підпорядкованим до цього протоколу типом. Щоб перевірити, чи було реалізовано опціональний метод, слід писати знак питання після імені методу, що викликається, наприклад: `someOptionalMethod?(someArgument)`. Детальніше з ланцюжками опціоналів можна ознайомитись у розділі [Ланцюжки опціоналів](15_optional_chaining.md).

У наступному прикладі оголошено клас на ім'я `Counter`, що реалізовує цілочисельний лічильник, котрий використовує зовнішнє джерело даних для визначення значення приросту. Це джерело даних визначається протоколом `CounterDataSource`, котрий має дві опціональних вимоги:

```swift
@objc protocol CounterDataSource {
    @objc optional func increment(forCount count: Int) -> Int
    @objc optional var fixedIncrement: Int { get }
}
```

Протокол `CounterDataSource` оголошує опціональну вимогу методу на ім'я `increment(forCount:)`, та опціональну вимогу властивості на ім'я `fixedIncrement`. Ці вимоги визначають два різних способи, в які джерело даних може надати значення приросту екземплярові  `Counter`.

> **Примітка**
>
> Строго кажучи, можна написати клас, що є підпорядкованим протоколу `CounterDataSource`, не реалізувавши жодну з його вимог. Врешті, вони обидві опціональні. Однак, хоч це й можливо технічно, на практиці це буде не дуже хороше джерело даних.

Клас `Counter`, оголошений нижче, має опціональну властивість `dataSource` типу `CounterDataSource?`:

```swift
class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.increment?(forCount: count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
```

Клас `Counter` зберігає поточне значення лічильника у властивості на ім'я `count`. Клас `Counter` також визначає метод `increment()`, що збільшує значення властивості `count` щоразу при виклику.

Метод `increment()` спершу намагається отримати значення приросту за допомогою методу `increment(forCount:)` його джерела даних. Метод `increment()` використовує ланцюжок опціоналів для виклику методу `increment(forCount:)`, і передає поточне значення `count` як єдиний аргумент цього методу.

Слід помітити, що в даному випадку мають місце два рівні ланцюжку опціоналів. Перший полягає в тому, що властивість `dataSource` може мати значення `nil` , і тому `dataSource` позначено знаком питання після її імені, щоб метод `increment(forCount:)` викликався лише тоді, коли `dataSource` не `nil`. Другий полягає в тому, що навіть якщо `dataSource` не `nil`, все ще нема гарантії, що воно реалізовує метод `increment(forCount:)`, оскільки це опціональна вимога. Тут можливість того, що метод `increment(forCount:)` не реалізований, опрацьовується за допомогою ланцюжка опціоналів. Виклик `increment(forCount:)` відбувається тільки тоді, коли він існує – тобто, коли він не `nil`. Тому виклик `increment(forCount:)` записується зі знаком питання після назви методу.

Оскільки виклик `increment(forCount:)` може впасти через одну з двох причин, виклик повертає опціональний `Int`. Це так, незважаючи на те, що у визначенні методу `increment(forCount:)` в протоколі `CounterDataSource` вказано не опціональний `Int`. І хоч в даному випадку ланцюжок опціоналів подвійний, результат є загорнутим лише в один опціонал. Детальніше з багаторівневими ланцюжками опціоналів можна ознайомитись у підрозділі [Зв'язування кількох рівнів ланцюжків опціоналів](15_optional_chaining.md#Linking-Multiple-Levels-of-Chaining).

Після виклику `increment(forCount:)`, опціональне значення `Int` повертається і розгортається у константу `amount`, за допомогою прив'язування опціоналу. Якщо опціональний `Int` має значення – тобто, `dataSource` та метод існують одночасно – розгорнуте значення `amount` додається до властивості `count`, що зберігається, і виклик `increment()` завершується.

Якщо витягнути значення з методу `increment(forCount:)` неможливо – або через те, що `dataSource` дорівнює `nil`, або через те, що `dataSource` не реалізовує метод `increment(forCount:)` – тоді метод `increment()` пробує витягнути значення із властивості `fixedIncrement`. Властивість `fixedIncrement` також є опціональною вимогою протоколу, тому її значення – опціональний `Int`, хоч в оголошенні протоколу `CounterDataSource` вона має не опціональний тип `Int`.

Ось приклад реалізації протоколу `CounterDataSource`, де джерело даних повертає константне значення `3` при кожному зверненні. Це робиться шляхом реалізації опціональної вимоги властивості `fixedIncrement`:

```swift
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}
```

Можна використовувати екземпляр `ThreeSource` як джерело даних нового екземпляру `Counter`:

```swift
var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    print(counter.count)
}
// 3
// 6
// 9
// 12
```

У коді вище створюється новий екземпляр `Counter`, після чого його властивості `dataSource` присвоюється новий екземпляр `ThreeSource`, і чотири рази викликається метод лічильника `increment()`. Як і очікується, властивість лічильника `count` збільшується на три при кожному виклику методу `increment()`.

Ось приклад складнішого джерела даних у вигляді класу `TowardsZeroSource`, що змушує екземпляр `Counter` змінювати значення `count` в сторону нуля:

```swift
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -> Int {
        if count == 0 {
            return 0
        } else if count < 0 {
            return 1
        } else {
            return -1
        }
    }
}
```

Клас `TowardsZeroSource` реалізовує опціональний метод `increment(forCount:)` з протоколу `CounterDataSource` і використовує значення аргументу `count` для визначення напрямку, в який слід робити відлік. Якщо `count` вже дорівнює нуля, метод повертає `0`, щоб позначити, що подальші зміни не потрібні.

Можна використати екземпляр `TowardsZeroSource` разом з існуючим екземпляром `Counter`, щоб відрахувати з `-4` до нуля. Як тільки лічильник досягає нуля, він перестає змінюватись:

```swift
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    print(counter.count)
}
// -3
// -2
// -1
// 0
// 0
```

### Розширення протоколів

Протоколи можна розширити, щоб додати реалізації методів, ініціалізаторів, індексів чи властивостей, що обчислюються, що підпорядкованих типів. Це дозволяє визначати поведінку в самих протоколах, замість того, щоб робити це окремо в кожному з підпорядкованих типів, чи в глобальній функції.

Наприклад, протокол `RandomNumberGenerator` можна розширити методом `randomBool()`, котрий використовує результат виклику методу `random()` для повернення випадкового булевого значення:

```swift
extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}
```

Створення розширення протоколу автоматично наділяє всі підпорядковані типи реалізаціями цього методу без їх додаткової модифікації.

```swift
let generator = LinearCongruentialGenerator()
print("Це випадкове число: \(generator.random())")
// Надрукує "Це випадкове число: 0.3746499199817101"
print("А це – випадкове булеве значення: \(generator.randomBool())")
// Надрукує "А це – випадкове булеве значення: true"
```

Розширення протоколів можуть додавати реалізації до підпорядкованих типів, за допомогою них не можна розширити протокол новими вимогами, чи успадкувати інший протокол. Наслідування завжди повинно бути зазначеним в оголошенні самого протоколу.

#### Реалізації вимог за замовчанням

За допомогою розширення протоколу можна надавати реалізації за замовчанням для будь-яких вимог методів чи властивостей, що обчислюються цього протоколу. Якщо підпорядкований тип має власну реалізацію вимоги методу чи властивості, ця реалізація буде використовуватись замість реалізації з розширення протоколу.

> **Примітка**
>
> Вимоги протоколу з реалізаціями за замовчанням, що містяться в розширення, це не те ж саме, що опціональні вимоги протоколу. Хоч підпорядковані типи й не повинні надавати власні реалізації в обох випадках, вимоги з реалізаціями за замовчанням можуть викликатись без ланцюжка опціоналів.

Наприклад, протокол `PrettyTextRepresentable`, що наслідує протокол `TextRepresentable`, може мати реалізацію вимоги властивості  `prettyTextualDescription`, котра просто повертатиме результат доступу до властивості `textualDescription`:

```swift
extension PrettyTextRepresentable  {
    var prettyTextualDescription: String {
        return textualDescription
    }
}
```

#### Додавання обмежень до розширень протоколів

При оголошенні розширення протоколу, можна вказати обмеження, які накладаються на підпорядковані типи, котрим будуть доступні методи та властивості з розширення протоколу. Ці обмеження записуються після назви протоколу, що розширюється, за допомогою інструкції узагальнення `where`. Детальніше з нею можна ознайомитись у підрозділі [Інструкція узагальнення Where](21_generics.md#Інструкція-узагальнення-Where).

Наприклад, можна визначити розширення протоколу `Collection`, що стосується лише колекцій, чиї елементи підпорядковані до протоколу `Equatable`. Обмежуючи елементи колекції до протоколу `Equatable`, котрий є частиною стандартної бібліотеки, можна використовувати оператори `==` та `!=` для визначення рівності/нерівності між двома елементами.

```swift
extension Collection where Element: Equatable {
    func allEqual() -> Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}
```

Метод `allEqual()` повертає `true` тільки у тому випадку, коли всі елементи в колекції рівні між собою.

Нехай є два масиви цілих чисел, в одному з яких усі елементи рівні, а в іншому - ні:

```swift
let equalNumbers = [100, 100, 100, 100, 100]
let differentNumbers = [100, 100, 200, 100, 200]
```

Оскільки масиви підпорядковуються до протоколу `Collection`, а цілі числа підпорядковуються до протоколу `Equatable`, в екземплярів  `equalNumbers` та  `differentNumbers` з'являється метод `allEqual()`:

```swift
print(equalNumbers.allEqual())
// Надрукує "true"
print(differentNumbers.allEqual())
// Надрукує "false"
```

> **Примітка**
>
> Якщо підпорядкований тип задовольняє вимогам кількох обмежених розширень, що містять реалізації одного й того ж методу чи властивості, Swift буде використовувати реалізацію, що відповідає найбільш конкретним обмеженням.



