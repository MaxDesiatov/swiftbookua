### Інструкції передачі контролю

_Інструкції передачі контролю_ міняють порядок, у якому виконується код, передаючи контроль з однієї секції коду в іншу. У мові Swift є п'ять інструкцій передачі контролю:

* `continue`
* `break`
* `fallthrough`
* `return`
* `throw`

Інструкції `continue`, `break`, та `fallthrough` описані нижче. Інструкція `return` описана у розділі [Функції](5_functions.md), а інструкція `throw` описана в підрозділі [Поширення помилок за допомогою функцій, що викидають помилки](16_error_handling.md#Поширення-помилок-за-допомогою-функцій,-що-викидають-помилки).

#### Інструкція Continue

Інструкція `continue` вказує поточному циклу, що слід припинити виконання поточної ітерації та почати наступну ітерацію циклу. Вона каже “я закінчив із поточною ітерацією циклу” без повного виходу із циклу.

У наступному прикладі із рядка, записаного малими літерами, видаляються всі голосні, пробіли та тире, для створення фрази-загадки:

```swift
let puzzleInput = "борітеся – поборете"
var puzzleOutput = ""
let charactersToRemove: [Character] = ["а", "е", "и", "i", "о", "у", "я", "ю", "є", "ï", " ", "–"]
for character in puzzleInput.characters {
    if charactersToRemove.contains(character) {
        continue
    } else {
        puzzleOutput.append(character)
    }
}
print(puzzleOutput)
// Надрукує "бртспбрт"
```

У коді вище інструкція `continue` викликається щоразу, коли поточний символ співпадає із голосним, пробілом чи тире, внаслідок чого поточна ітерація циклу одразу завершується, а цикл переходить до наступної ітерації.

#### Інструкція Break

Інструкція `break` зупиняє виконання поточного потоку керування. Інструкцію `break` можна використовувати всередині інструкції `switch` або циклу, коли потрібно перервати виконання інструкції `switch` чи циклу раніше, ніж би це відбулось за звичайних умов.

##### Інструкція Break у циклі

При використанні всередині циклу, інструкція `break` завершує виконання циклу та негайно передає контроль до коду після фігурної дужки, що закриває тіло циклу \(`}`\). Подальший код в поточній ітерації не виконується, а наступні ітерації циклу не розпочинаються.

##### Інструкція Break в інструкції Switch

При використанні всередині інструкції `switch`, інструкція `break` негайно завершує її виконання і передає контроль до коду після фігурної дужки, що закриває `switch` \(`}`\).

Ця поведінка може бути використана для ігнорування одного чи більше випадків в інструкції `switch`. Інструкція `switch` у мові Swift повинна бути вичерпною і не дозволяє створювати порожні випадки, але при цьому іноді потрібно свідомо ігнорувати певні випадки, щоб зробити намір коду явним. Зробити це можна, написавши інструкцію `break` замість тіла випадку, який потрібно проігнорувати. Коли виконання потрапляє у такий випадок, інструкція `break` всередині його негайно зупиняє виконання інструкції `switch`.

> **Примітка**
>
> Випадок в іструкції `switch`, що містить лише коментар, також призводить до помилки компіляції. Коментарі не є інструкціями і не дозволяють ігнорувати випадок. Тому слід завжди використовувати інструкцію  `break` для ігнорування випадку в `switch`.

У наступному прикладі розглядається значення `Character` та визначається, чи представляє воно значення числа в одній із чотирьох мов. Для стислості, в інструкції `switch` використовуються об'єднані випадки.

```swift
let numberSymbol: Character = "三"  // Китайський символ числа 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    print("Цілочисельне значення символу \(numberSymbol) дорівнює \(integerValue).")
} else {
    print("Неможливо визначити цілочисельне значення символу \(numberSymbol).")
}
// Надрукує "Цілочисельне значення символу 三 дорівнює 3."
```

У цьому прикладі розглядається символ `numberSymbol`, ти визначається, чи є він латинським, арабським, китайським чи тайським записом числа від `1` до `4`. Якщо він співпав з одним із шаблонів, у відповідному випадку інструкції `switch` опціональній змінній `possibleIntegerValue` типу `Int?` присвоюється відповідне цілочисельне значення.

Після завершення інструкції `switch`, у прикладі використовується прив'язування опціоналу для визначення, чи було знайдено цілочисельне значення. Змінній `possibleIntegerValue` неявно присвоюється початкове значення `nil` через те, що вона має опціональний тип. Тому прив'язування опціоналу буде успішним тоді, коли змінній `possibleIntegerValue` було присвоєно реальне значення в одному із чотирьох випадків інструкції `switch`.

Оскільки перелічувати всі можливі значення `Character` у прикладі вище не практично, випадок за замовчанням `default` покриває всі символи, що не співпали. Цей випадок за замовчанням не повинен виконувати жодної дії, і тому його тіло складається з єдиної інструкції `break`. Як тільки спрацьовує випадок за замовчанням, інструкція `break` призводить до виходу з інструкції `switch`, і виконання коду переходить до наступної інструкції `if let`.

##### Перехід до наступного випадку

У Swift, виконання інструкції `switch` не переходить в кінці одного випадку до виконання наступного автоматично. Натомість, виконання всієї інструкції `switch` завершується, як кільки відпрацював перший із випадків, що співпав. На відміну від Swift, в мові C для такої поведінки потрібно явно вказувати інструкцію `break` в кінці кожного випадку. Уникання автоматичних переходів у Swift робить інструкції `switch` більш стислими й передбачуваними, ніж їх аналоги з мови C, бо унеможливлюється помилковий виклик кількох випадків замість одного.

Однак, якщо потрібна саме поведінка інструкцій `switch` в стилі мови C, її можна увімкнути у кожному конкретному випадку за допомогою ключового слова `fallthrough`. У наступному прикладі ключове слово `fallthrough` використовується для створення текстового опису числа.

```swift
let integerToDescribe = 5
var description = "Число \(integerToDescribe) є"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " простим числом, і також"
    fallthrough
default:
    description += " цілим."
}
print(description)
// Надрукує "Число 5 є простим числом, і також цілим."
```

В даному прикладі оголошено змінну типу `String` на ім'я `description`, якій присвоєно початкове значення. Потім розглядається значення `integerToDescribe` за допомогою інструкції `switch`. Якщо значення `integerToDescribe` співпадає з одним із простих значень у списку, до тексту `description` додається повідомлення, що дане число є простим. Потім, за допомогою ключового слова `fallthrough` відбувається перехід до наступного випадку, `default`. Випадок `default` додає кінцівку в текст `description`, на чому інструкція `switch` завершується.

Якщо ж значення `integerToDescribe` не співпадає з жодним зі значень у списку простих значень, перший випадок інструкції `switch` не виконується. Оскільки більше нема особливих випадків, виконується випадок за замовчанням `default`.

Після завершення виконання інструкції `switch`, опис числа друкується за допомогою функції `print(_:separator:terminator:)`. В даному прикладі було коректно визначено, що число `5` є простим.

> **Примітка**
>
> Ключове слово `fallthrough` не перевіряє умову випадку, до виконання якого воно призводить. Ключове слово `fallthrough` просто змушує виконання коду перейти напряму до інструкцій всередині тіла наступного випадку \(або випадку за замовчанням `default`\), як і в стандартній поведінці інструкції `switch` у мові C.

### Іменовані інструкції

У Swift, можна вкладати цикли чи умовні інструкції всередині інших циклів чи умовних інструкцій, щоб створювати складніші структури управління потоком виконання. Однак, всередині циклів та умовних інструкцій можуть бути інструкції `break` для раннього виходу з них. Таким чином, іноді виникає необхідність у явному позначенні, з якого саме циклу чи умовної інструкції потрібно вийти за допомогою інструкції `break`. Аналогічно, у випадку кількох вкладених циклів, іноді може бути корисним явно вказувати, що якого з циклів повинна відноситись інструкція `continue`.

Щоб досягнути цих цілей, інструкції циклів чи умов можна робити _іменованими_. В умовних інструкціях, ім'я інструкції може використовуватись разом з інструкцією `break` для завершення її виконання. В інструкції циклу, ім'я інструкції може використовуватись разом з інструкціями `break` та `continue` для управління відповідною іменованою інструкцією.

Іменування інструкції відбувається за допомогою вказування імені інструкції на тому ж рядку, де знаходиться перше ключове слово даної інструкції, та двокрапки. Ось приклад даного синтаксису для циклу `while`, хоча принцип є однаковим для всіх циклів та інструкцій `switch`:

```swift
<ім'я інструкції>: while <умова> {
    <інструкції>
}
```

У наступному прикладі використовуються інструкції `break` та `continue` всередині іменованого циклу `while` для переробленої версії гри _Ліла_, з котрою ми ознайомились вище у цьому розділі. Цього разу, у грі є додаткове правило:

* Для виграшу, потрібно потрапити _точно_ на клітинку 25.

Якщо певний кидок костей призводить до переходу за клітинку 25, потрібно кидати кості знову, допоки не випаде число, що приведе точно на клітинку 25.

Ігрова дошка є такою ж, як і раніше.

![](images/snakesAndLadders_2x.png)  
￼  
Значення змінних `finalSquare`, `board`, `square`, та `diceRoll` ініціалізуються так само, як і раніше:

```swift
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
```

В даній версії гри використовується цикл `while` з інструкцією `switch` всередині для реалізації ігрової логіки. Цикл `while` тепер є іменованою інструкцією з іменем `gameLoop`, щоб вказати, що він є головним циклом у грі Ліла.

Умовою циклу `while` є `while square != finalSquare`, що відображає нове правило щодо потрапляння точно на клітинку 25.

```swift
gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // кидок костей пересуне нас на останню клітинку, тому гру закінчено
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // кидок костей пересуне нас за мені ігрового поля, тому слід кидати кості ще раз
        continue gameLoop
    default:
        // даних хід є коректним, тому слід визначити його ефект (змії, сходи чи нічого)
        square += diceRoll
        square += board[square]
    }
}
print("Гру завершено!")
```

Кості кидаються на початку кожної ітерації циклу. Замість того, щоб одразу пересунути гравця, тепер використовується інструкція `switch`, що розглядає результат майбутнього руху та визначає, чи цей рух взагалі можливий:

* Якщо кидок костей пересуне гравця на останню клітинку, гру завершено. Інструкція `break gameLoop` передає контроль до першого рядку після циклу `while`, що й завершує гру.
* Якщо кидок костей пересуне гравця за межі ігрового поля, рух є неможливим і гравець повинен кидати кості ще раз. Інструкція `continue gameLoop` завершує поточну ітерацію циклу `while` та розпочинає наступну ітерацію циклу.
* В усіх інших випадках, кидок костей призводить до коректного руху. Гравець рухається вперед на `diceRoll` клітинок, і гра перевіряє наявність змій чи сходів. Після цього ітерація циклу завершується, і контроль переходить до перевірки умови циклу, щоб визначити, чи потрібен ще один хід.

> **Примітка**
>
> Якщо інструкція `break` би не використовувала ім'я `gameLoop`, то вона перервала би інструкцію `switch`, а не цикл `while`. Використання імені `gameLoop` робить зрозумілим, яку саме інструкцію потрібно перервати.
>
> Немає строгої необхідності використовувати ім'я `gameLoop` при виклику `continue gameLoop` для переходу на наступну ітерацію циклу. Це єдиний цикл у грі, і тому немає невизначеності, до якого із циклів відноситься інструкція `continue`. Однак, так само немає жодної шкоди у використанні імені `gameLoop` разом з інструкцією `continue`. Використання імені робить код послідовнішим \(вище ми використовуємо ім'я з інструкцією `break`\), та допомагає легше читати і розуміти код ігрової логіки.

### Ранній вихід

Інструкція `guard`, як і інструкція `if`, виконує код в залежності від значення булевого виразу. Інструкцію `guard` слід використовувати тоді, коли певна умова повинна бути істинною \(`true`\) для подальшого виконання коду. На відміну від інструкції `if`, в інструкції `guard` завжди є пункт `else` - код всередині пункту `else` виконується, коли умова хибна \(`false`\).

```swift
func greet(person: [String: String]) {
    guard let name = person["name"] else {
        return
    }

    print("Вітаємо, \(name)!")

    guard let location = person["city"] else {
        print("Сподіваємось, погода біля вас непогана.")
        return
    }

    print(Сподіваємось, погода у місті \(location) непогана.")
}

greet(person: ["name": "Іван"])
// Надрукує "Вітаємо, Іван!"
// Надрукує "Сподіваємось, погода біля вас непоганаи."
greet(person: ["name": "Марічка", "city": "Київ"])
// Надрукує "Вітаємо, Марічка!"
// Надрукує "Сподіваємось, погода у місті Київ непогана."
```

Якщо умова всередині інструкції `guard` виконується, код продовжує виконуватись після закриття фігурної дужки цієї інструкції \(`}`\). Всі константи та змінні, що їм було присвоєно значення за допомогою прив'язування опціоналів всередині умови, будуть доступними до кінця блоку коду, де записаний даний `guard`.

Якщо умова всередині інструкції `guard` не виконується, відбувається виконання коду всередині інструкції `else`. Ця гілка коду обов'язково повинна передати контроль до виходу з блоку коду, де записаний даний `guard`. Вона може це зробити за допомогою інструкцій передачі контролю, таких як `return`, `break`, `continue`, чи `throw`, або вона може викликати метод чи функцію, з якої нема повернення, таку як `fatalError(_:file:line:)`.

Інструкція `guard` найкраще підходить для запису передумов певного коду, використання її покращує читабельність коду, якщо порівнювати з аналогічним кодом, записаним за допомогою інструкції `if`. Вона дозволяє записувати основну гілку коду, що як правило, виконується, без обгортання її в блок `else`, та дозволяє тримати код, що відноситься до обробки порушених передумов поруч із самими передумовами.

### Перевірка доступності API

У мові Swift є вбудована підтримка перевірки доступності API, котра убезпечує вас від випадкового використання API, що недоступне на тій чи іншій версії тої чи іншої платформи.

Компілятор використовує інформацію про доступність в SDK для перевірки, що всі API використані у вашому коді є доступними на тій версії ОС, що ви вказали у вашому проєкті як мінімальну \(deployment target\). Якщо  
спробувати використати недоступне API, компілятор Swift повідомить про відповідну помилку.

Однак, іноді потрібно використовувати API, що доступні не на всіх версіях ОС, що підтримує ваша програма. Для цього слід використовувати _умови доступності_ в інструкціях `if` чи `guard`, щоб певний код виконувався чи не виконувався в залежності від того, чи є певні API доступними під час виконання. Компілятор використовує інформацію про доступність з умови доступності при перевірці, чи всі API у даному блоці коду є доступними.

```swift
if #available(iOS 10, macOS 10.12, *) {
    // Використання API, доступних починаючи із iOS 10 та macOS 10.12
} else {
    // Повернення до більш ранніх API iOS та macOS
}
```

Умови доступності вище вказують, що на iOS, тіло `if` буде виконуватись тільки на версії 10 або вище; на macOS, тільки на версії 10.12 або вище. Останній аргумент, `*`, потрібний для того, щоб вказати, що на будь-яких інших платформах, тіло `if` буде виконуватись на мінімальній версії ОС, вказаній у налаштуваннях проєкту \(deployment target\).

У загальній формі, умова доступності приймає список платформ на їх версій. Слід вказувати назви платформ, такі, як `iOS`, `macOS`, `watchOS`, та `tvOS` — повний список можна знайти у розділі [Declaration Attributes](). Крім основних номерів версій, як iOS 8, можна вказувати також і мінорні номери версій, як iOS 8.3 та macOS 10.10.3.

```swift
if #available(<ім'я платформи> <версія>, ..., *) {
    <інструкції для виконання, якщо API доступні>
} else {
    <інструкції для виконання, якщо API недоступні>
}
```



