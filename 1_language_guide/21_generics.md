## Узагальнення

*Узагальнений код* дозволяє писати гнучкі функції та типи, котрі можна повторно використовувати, що працюють із будь-якими типами відповідно до ваших вимог. Таким способом можна писати код, що уникає повторень, та виражає намір автора у зрозумілій та абстрагованій манері. 

Узагальнення є однією з найбільш потужних можливостей мови Swift, і велика частина стандартної бібліотеки Swift побудована за допомогою узагальненого коду. Фактично, ми користувались узагальненнями всюди у *Керівництві з мови*, навіть якщо ми не усвідомлювали цього. Наприклад, типи `Array` та `Dictionary` у Swift є узагальненими колекціями. Можна створити масив, що зберігає значення типу `Int`, або типу `String`, або будь-якого іншого типу, що можна створити у Swift. Аналогічно, можна створити словник, що зберігає значення будь-якого вказаного типу, і немає жодних обмежень щодо типу цих значень. 

### Проблема, котру вирішують узагальнення

Ось стандартна, неузагальнена функція, що називається `swapTwoInts(_:_:)`, та міняє місцями два значення типу `Int`:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

Ця функція для обміну значень `a` та `b` використовує двонаправлені параметри, що описані у підрозділі [Двонаправлені параметри](5_functions.md#Двонаправлені-параметри).

Функція `swapTwoInts(_:_:)` підставляє початкове значення `b` у змінну `a`, і початкове значення `a` у змінну  `b`. Можна викликати цю функцію для обміну двох значень типу `Int`:

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt тепер дорівнює \(someInt), а anotherInt тепер дорівнює \(anotherInt)")
// Надрукує "someInt тепер дорівнює 107, а anotherInt тепер дорівнює 3"
```

Функція `swapTwoInts(_:_:)` є корисною, але її можна застосувати лише до пари значень типу `Int`. Якщо потрібно обміняти значеннями дві змінні типу `String` чи `Double`, потрібно написати ще функцій, наприклад `swapTwoStrings(_:_:)` та `swapTwoDoubles(_:_:)`:

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

Слід помітити, що тіла функцій `swapTwoInts(_:_:)`, `swapTwoStrings(_:_:)`, та `swapTwoDoubles(_:_:)` повністю співпадаються. Єдиною відмінністю є тип значень, що приймають ці функції (`Int`, `String`, та `Double`).

Було б ефективніше та набагато більш гнучко написати одну функцію, що обмінює значеннями два значення будь-якого типу. Узагальнений код дозволяє написати таку функцію. (Узагальнена версія цих трьох функцій оголошується далі).

> **Примітка**
>
> У всіх цих трьох функціях, тип у змінних `a` та `b` має бути однаковим. Якщо тип у `a` та `b` не співпадає, неможливо обміняти їх значеннями. Swift є типобезпечною мовою, і тому не дозволяє (наприклад) обміняти значеннями змінні типу `String` та `Double`. Спроба зробити це призводить до помилки часу компіляції.

### Узагальнені функції

Узагальнені функції можуть працювати з будь-яким типом. Ось приклад узагальненої версії функції `swapTwoInts(_:_:)` з прикладу вище, котра називається `swapTwoValues(_:_:)`:

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

Тіло функції `swapTwoValues(_:_:)` є ідентичним до тіла функції `swapTwoInts(_:_:)`. Однак, перший рядок функції `swapTwoValues(_:_:)` трохи відрізняється від `swapTwoInts(_:_:)`. Ось перші два рядки в порівнянні:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

Узагальнена функція використовує замісник назви типу (що в даному випадку називається `T`) замість фактичної назви типу (на кшталт `Int`, `String`, чи `Double`). Замісник назви типу нічого не каже про то, чим може бути  `T`, але він каже, що `a` та `b` повинні мати однаковий тип `T`, яким би він не був. Фактичний тип для використання замість `T` встановлюється в момент виклику функції `swapTwoValues(_:_:)`.

Різниця між узагальненою та неузагальненою функцією полягає також у тому, що після назви узагальненої функції (`swapTwoValues(_:_:)`) йде замісник назви типу (`T`) у фігурних дужках (`<T>`). Фігурні дужки підказують  компілятору Swift, що `T` – це замісник назви типу у визначенні функції `swapTwoValues(_:_:)`. Оскільки `T` – це замісник назви типу, компілятор Swift не шукатиме фактичний тип, що називається `T`.

Функція `swapTwoValues(_:_:)` може тепер викликатись так само, як і `swapTwoInts(_:_:)`, але їй можна передавати пару значень будь-якого типу, головне, щоб це були значення одного й того ж типу. При кожному виклику `swapTwoValues(_:_:)`, тип, який слід використовувати замість `T`, визначається з типів значень, що передаються до функції.

У двох прикладах нижче, `T` визначається як `Int`  та  `String` відповідно:

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt тепер дорівнює 107, а anotherInt тепер дорівнює 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString тепер дорівнює "world", а anotherString тепер дорівнює "hello"
```

> **Примітка**
>
> Визначена вище функція `swapTwoValues(_:_:)` є аналогом узагальненої функції `swap(::)`, що є частиною стандартної бібліотеки Swift, та є автоматично доступною для використання у ваших додатках. Якщо вам потрібна поведінка функції `swapTwoValues(_:_:)` у вашому коді, слід використовувати існуючу функцію `swap(::)` замість того, щоб реалізовувати її самотужки.

### Параметри типів

У прикладі з `swapTwoValues(_:_:)`, замісник назви типу `T` є прикладом параметра типу. Параметри типів визначають та іменують замісник типу, і записуються одназу після назви функції, всередині пари кутових дужок (наприклад, `<T>`).

Як тільки вказано параметр типу, його можна використовувати для визначення типу параметрів функції (наприклад, типи параметрів `a` та `b` функції `swapTwoValues(_:_:)`), або типу, що повертається функцією, або як анотацію типу всередині тіла функції. В кожному випадку, тип параметра замінюється фактичним типом при кожному виклику функції. (У прикладі з `swapTwoValues(_:_:)` вище, `T` замінювався на `Int` у першому виклику функції, та на `String` у другому виклику функції).

Функція може мати декілька параметрів типів, їх так само записують у кутових дужках, розділюючи комами. 

#### Іменування параметрів типів

У більшості випадків, параметри типів мають змісновті назви, як наприклад `Key` (ключ) та `Value` (значення) у `Dictionary<Key, Value>`, котрі вказують читачу на зв'язкок між параметром типу та узагальненим типом або функцією, в якому він використовується. Однак, у випадках, коли між ними нема змістовного зв'язку, традиційно типи параметрів однією великою літерою, зазвичай `T`, `U`, чи `V`, як `T` у функції `swapTwoValues(_:_:)` вище.

> **Примітка**
>
> Слід завжди давати параметрам типів назви, що пишуться [ВерхнімВерблюжимРегістром](https://uk.wikipedia.org/wiki/Верблюжий_регістр) (наприклад, `T` або `MyTypeParameter`), щоб позначити, що це замісник типу, а не значення.

### Узагальнені типи

Окрім узагальнених функцій, Swift дає можливість створювати власні *узагальнені типи*. Ними можуть бути власні класи, структури та перечислення, що можуть працювати з будь-яким типом, аналогічно до вбудованих `Array` та `Dictionary`.

Цей підрозділ покаже, як написати власну узагальнену колекцію на ім'я `Stack`. Стек - це впорядкована множина значень, аналогічна до масиву, але із більш обмеженим набором операцій, ніж у масивів у Swift. Масиви у Swift дозволяють вставляти чи видаляти елементи в будь-якій позиції. Стек дозволяють новим елементам додаватись лише в кінець колекції (про що кажуть: "заштовхнути елемент у стек", або push). Стек також дозволяє елементам видалятись, але лише з кінця колекції (про що кажуть: "виштовхнути елемент зі стека", або pop).

> **Примітка**
>
> Концепція стеку використовується класом `UINavigationController` для моделювання в'ю-контоллерів у ієрархії навігації в додатках на iOS. Щоб додати в'ю-контроллер до навігаційного стеку, слід викликати метод `pushViewController(_:animated:)` класу `UINavigationController`, а щоб прибрати (тобто виштовхнути) в'ю-контроллер з навігаційного стеку – метод `popViewControllerAnimated(_:)`. Стек є корисною моделлю колекції в тих випадках, де для керування колекцією потрібне строге правило “останнім прийшов — першим пішов” (або LIFO, від англійсього “last in, first out”).

Ілюстрація нижче демонструє поведінку стека і його операції push та pop:

![](images/stackPushPop_2x.png)

1. У стеку зберігаються три значення.
2. До стеку заштовхується четверте значення.
3. Стек тепер тримає чотири значення, при цьому останнє лежить на його вершині.
4. Зі стеку виштовхується значення.
5. Після виштовхування значення, стек знову містить три початкові значення.

Ось як можна записати неузагальнену версію стеку, в даному випадку для стеку значень типу `Int`:

```swift
struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
```

У даній струкрурі для зберігання значень у стеку використовується масив значень типу `Int`, що зберігається у властивості на ім'я `items`. Цей стек має два методи, `push()` та  `pop()`, що відповідно заштовхують та виштовхують елементи стеку. Ці методи позначені модифікатором `mutating`, оскільки їм потрібно змінити масив, що зберігається у даній структурі.

Однак тип `IntStack` може використовуватись лише для зберігання значень типу `Int`. Було б набагато більш ефективно створити узагальнений клас `Stack`, котрий би керував стеком значень будь-якого типу. 

Ось узагальнена версію того ж коду:

```swift
struct Stack<Element> {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

Слід помітити, що узагальнена версія `Stack` є практично такою ж, як і неузагальнена версія, єдиною відмінністю є параметр типу на ім'я `Element` замість фактичного типу `Int`. Параметр типу записується всередині пари кутових дужок (`<Element>`) одразу після назви структури.

`Element` визначає замісник назви типу, що буде надана пізніше. До цього майбутнього типу далі можна звертатись як `Element` будь-де у визначенні структури. В даному випадку, `Element` використовується як замісник у трьох місцях:

- Для створення властивості `items`, котра ініціалізується порожнім масивом значень типу `Element`.
- Щоб вказати, що метод `push(_:)` має єдиний параметр на ім'я `item`, котрий повинен мати тип `Element`.
- Щоб вказати, що метод `pop()` повертає значення типу `Element`.

Оскільки `Stack` є узагальненим типом, його можна використовувати для створення стеку будь-якого типу Swift, аналогічно до `Array` та `Dictionary`.

Щоб створити новий екземпляр `Stack`, слід записати тип значень, що зберігатиметься у стеку, у фігурних дужках. Наприклад, щоб створити стек рядків, слід написати `Stack<String>()`:

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// стек містить 4 рядки
```

Ось як виглядає стек `stackOfStrings` після заштовхування в нього чотирьох значень:

![](images/stackPushedFourStrings_2x.png)

Виштовхування значень зі стеку видаляє та повертає значення на вершині стеку, `"cuatro"`:

```swift
let fromTheTop = stackOfStrings.pop()
// fromTheTop тепер дорівнює "cuatro", а стек тепер містить 3 рядки
```

Ось як виглядає стек після виштовхування верхнього значення:

![](images/stackPoppedOneString_2x.png)

### Розширення узагальнених типів

При розширенні узагальненого типу не потрібно вказувати список параметрів типів у оголошенні розширення. При цьому список параметрів типів з оригінального оголошення типу є доступним для тіла розширення, і оригінальні назви параметрів типів можна використовувати для посилання на параметри в оригінальному оголошенні. 

Наступний приклад розширює узагальнений тип `Stack`, додаючи до нього властивість тільки для читання, що обчислюється і називається `topItem`, котра повертає елемент на вершині стеку, без виштовхування цього елементу зі стеку:

```swift
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
```

Властивість `topItem` повертає опціональне значення типу `Element`. Якщо стер порожній, `topItem` поверне `nil`; якщо стек не порожній, `topItem` поверне останній елемент у масиві `items`.

Варто помітити, що розширення не оголошує список параметрів типів. При цьому назва існуючого параметра типу `Element` використовується всередині розширення для позначення опціонального типу властивості `topItem`.

Властивість, що обчислюється, `topItem` тепер може бути використаною з будь-яким екземпляром `Stack` для отримання елемента на вершині стеку без його видалення:

```swift
if let topItem = stackOfStrings.topItem {
    print("Елементом на вершині стеку є '\(topItem)'.")
}
// Надрукує "Елементом на вершині стеку є 'tres'."
```

Розширення узагальненого типу можуть також включати вимоги, котрі мають задовольняти типи, що отримають нову функціональність. Це детальніше описано далі, в підрозділі [Розшинення з інструкцією узагальнення Where](#Розшинення-з-інструкцією-узагальнення-Where).

### Обмеження типів

Функція  `swapTwoValues(_:_:)` та тип `Stack` можуть працювати із будь-яким типом. Однак, часто буває потрібно накласти певні обмеження на типи, які можуть використовуватись в узагальнених функціях та типах. Обмеження типів вказують, що параметр типу повинен наслідуватись від певного класу, або підпорядковуватись певному протоколу, чи композиції протоколів.

Наприклад, тип `Dictionary` у Swift вводить обмеження на типи, що можуть використовуватись в якості ключів у словнику. Як описано у підрозділі [Словники](3_collection_types.md#Словники), тип ключа у словнику має підпорядковуватись протоколу `Hashable`, тобто вміти обчислити свій хеш. Іншими словами, ключ повинен надавати своє однозначне представлення. Словнику потрібно знаходити хеш ключа для того, щоб перевіряти, чи містить він для цього ключа значення. Без цього обмеження, словник не мав би змоги з'ясувати, потрібно вставляти нове значення чи заміняти існуючи, а також не мав би змоги з'ясувати, чи міститься у ньому значення за заданим ключем. 

Дана вимога ставиться за допомогою обмеження типу ключа для `Dictionary`, котра визначає, що ключ має підпорядковуватись протоколу `Hashable`, спеціальному протоколу зі стандартної бібліотеки Swift. Всі базові типи Swift (такі, як `String`, `Int`, `Double`, та `Bool`) є за замовчанням підпорядкованими цьому протоколу. 

Створюючи власні узагальнені типи, можна ставити власні обмеження типів, і ці обмеження містять у собі велику силу узагальненого програмування. Абстрактні концепції на кшталт `Hashable` характеризуть типи з точки зору їх концептуальних характеристик, допомагаючи уникати використання конкретних типів. 

#### Синтаксис обмежень типів

Обмеження типів записуються шляхом вказування назви класу чи протоколу у списку параметрів типів, після назви параметру типу, відділяючись від нього комою. Базовий синтаксис обмеження типів узагальненої функції показано нижче (синтаксис для узагальнених функцій та типів однаковий):

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // тут йде тіло функції
}
```

Гіпотетична функція вище має два параметри типів. Перший параметр типу, `T`, має обмеження типу, що вимагає `T` бути класом-нащадком класу  `SomeClass`. Другий параметр, `U`, має обмеження типу, що вимагає `U` бути підпорядкованим протоколу `SomeProtocol`.

#### Обмеження типів у дії

Ось приклад неузагальненої функції на ім'я `findIndex(ofString:in:)`, котра шукає зананий рядок у заданому масиві рядків. Функція `findIndex(ofString:in:)` повертає опціональне цілочисельне значення, котре виражає індекс першого рядка в масиві, що співпав із заданим, або `nil`, якщо не співпав жоден:

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

Функцію `findIndex(ofString:in:)` можна використовувати для знаходження рядку у масиві рядків:

```swift
let strings = ["кіт", "пес", "лама", "папуга", "черепаха"]
if let foundIndex = findIndex(ofString: "лама", in: strings) {
    print("Рядок 'лама' має індекс \(foundIndex)")
}
// Надрукує "Рядок 'лама' має індекс 2"
```

Однак, принцип знаходження індексу значення в масиві може стати в нагоді не лише для рядків. Можна написати аналогічну функціональність у вигляді узагальненої функції, замінюючи згадки типу `String` на параметр типу `T`.

Ось як можла б виглядати узагальнена версія функції `findIndex(ofString:in:)`, що носила б назву `findIndex(of:in:)`. Слід помітити, що тип, що повертається цією функцією, все ще є `Int?`, оскільки функція повертає опціональний індекс у масиві, а не опціональне значення з масиву. Однак, маємо попередити: дана функція не скомпілюється через причини, які ми пояснимо далі після цього прикладу:

```swift
func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

Функція вище не скомпілюється. Проблема лежить в перевірці на рівність,  “`if value == valueToFind`”. Не кожен тип у Swift можна порівнювати за допомогою оператору рівності (`==`). Якщо, наприклад, створити власний клас чи структуру, що представляє якусь модель даних, тоді значення операції “дорівнює” для цього класу чи структури не є очевидним для Swift, і компілятор не може його вгадати. Через це, неможливо гарантувати, що даний код буде працювати для будь-якого можливого типу `T`, і компілятор вкаже на це у повідомленні про помилку. 

Однак, не все втрачено. У стандартній бібліотеці Swift є протокол, що носить назву `Equatable`, котрий вимагає в підпорядкованого типу реалізовувати оператори рівності (`==`) та нерівності (`!=`) для порівняння двох значень даного типу. Всі стандартні типи Swift автоматично підпорядковані протоколу `Equatable`.

Будь-який тип, підпорядкований протоколу `Equatable`, можна безпечно використовувати у функції `findIndex(of:in:)`, оскільки він гарантовано підтриимує оператор рівності. Для вираження цього факту, вимога підпорядковуватись протоколу `Equatable` записується як обмеження типу `T` у визначенні функції:

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

Єдиний параметр типу функції `findIndex(of:in:)` записуєтсья як `T: Equatable`, що означає “будь-який `T`, що підпорядковується протоколу `Equatable`.

Функція `findIndex(of:in:)` тепер успішно компілюється та може використовуватись із будь-яким підпорядкованим протоколу `Equatable` типом, наприклад, `Double` чи `String`:

```swift
let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex є опціональним Int без значення, бо значення 9.3 відсутнє в масиві
let stringIndex = findIndex(of: "Антоніна", in: ["Михайло", "Максим", "Антоніна"])
// stringIndex є опціональним Int зі значенням 2
```

### Асоційовані типи

При визначенні протоколу, іноді буває зручно оголошувати один чи декілька асоційованих типів у оголошенні протоколу. Асоційовані типи виступають замісником назви типу, що може використовуватись у протоколі. Фактичний тип заміщує асоційований тип в момент підпорядкування протоколу якимось типом. Асоційовані типи оголошуються за домопогою ключового слова `associatedtype`.

#### Асоційовані типи в дії

Ось приклад протоколу, що носить назву `Container` та оголошує асоційований тип на ім'я `Item`:

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

Протокол `Container` визначає три необхідні можливості, що повинен надавати будь-який контейнер:

- Додавати нові елементи в контейнер за допомогою методу `append(_:)`.
- Дізнаватись про кількість елементів у контейнері за допомогою цілочислельної властивості для читання `count`
- Отримувати елемент з контейнеру за цілочисельним індексом.

Даний протокол не визначає, як повинні зберігатися елементи в контейнері, чи якого типу вони повинні бути. Протокол визначає лише три кавалки функціональності, котрі повинний надати тип для того, щоб вважатись контейнером. Підпорядкований тип може надавати й додаткову функціональність, однак при цьому він повинен задовольняти дані три вимоги. 

Будь-який підпорядкований протоколові `Container` тип повинен вказати тип значення, що в ньому зберігатимуться. Зокрема, він має гарантувати, що додати до контейнера можна лише елементи правильного типу, і що дістати з контейнера за індексом можна лише елементи цього ж типу. 

Щоб визначити ці вимоги, протокол `Container` повинен посилатись на тип елементів, що зберігатимуться в контейнері, не знаючи якого конкретно вони будуть типу. Протокол `Container` повинен вказати, що будь-яке значення, що передається до методу `append(_:)` повинно мати той же тип, що зберігається у контейнері, і що значення, котре повертається індексом контейнера теж має той же тип, що зберігається у контейнері.

Щоб досягти цього, у протоколі `Container` оголошується асоційований тип на ім'я `Item`, що записується як `associatedtype Item`. Протокол не визначає, чим є `Item`: право визначати цю інформацію залишається за підпорядкованим типом. І тим не менше, псевдонім `Item` надає спосіб посилатись на тип елементів у протоколі `Container`: визначати тип, що передається до методу `append(_:)` та повертається індексом, і таким чином змушувати будь-який `Container` мати очікувану поведінку. 

Ось приклад неузагальненого типу `IntStack` з підрозділу [Узагальнені типи](#Узагальнені-типи) вище, котрий було підпорядковано протоколу `Container`:

```swift
struct IntStack: Container {
    // початкова реалізація IntStack
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
    // підпорядкування протоколу Container
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Int {
        return items[i]
    }
}
```

Тип `IntStack` реалізовує всі три вимоги протоколу `Container`, і в кожному випадку вже існуюча частина функціональності `IntStack` обгортається для задоволення цих вимог.

Більше того, структура `IntStack` тепер визначає, що для даної реалізації протоколу `Container`, тип `Int` грає роль типу `Item`. Визначення псевдоніму `typealias Item = Int` перетворює абстрактний тип `Item` на конкретний тип `Int` для цієї реалізації протоколу `Container`.

Завдяки визначенню типів у Swift, фактично не потрібно визначати конкретний `Item` типу `Int` у оголошенні `IntStack`. Оскільки `IntStack` підпорядковується до усіх вимог протоколу `Container`, Swift може визначати відповідний тип для використання у ролі `Item`, просто поглянувши на тип параметра методу `append(_:)`, або тип, що повертається індексом. Справді, якщо з коду видалити рядок із псевдонімом типу `typealias Item = Int`, він все одно працюватиме, оскільки зрозуміло, який тип слід використовувати в якості `Item`.

Узагальнений тип `Stack` можна також підпорядкувати протоколу `Container`:

```swift
struct Stack<Element>: Container {
    // початкова реалізація Stack<Element>
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
    // підпорядкування протоколу Container
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Element {
        return items[i]
    }
}
```

Цього разу, в якості типу параметру методу `append(_:)`, та типу, що повертається індексом, використовується тип `Element`. В цьому випадку визначення типів у Swift знову допомагає встановити, що в якості типу `Item` слід використовувати тип `Element`.

#### Розшинення існуючого типу для визначення асоційованого типу

Існуючі типи можна розширювати для підпорядкування їх певному протоколу, як це описано у підрозділі [Підпорядкування протоколу за допомогою розширення](20_protocols.md#Підпорядкування-протоколу-за-допомогою-розширення). Це стосується також і протоколів з асоційованими типами. 

Тип `Array` у Swift вже має метод `append(_:)`, властивість `count` та цілочисельний індекс, що повертає його елементи. Ці три можливості співпадають з вимогами протоколу `Container`. Це означає, що можна розширити масив, підпорядковуючи його протоколові `Container`, просто оголосивши, що `Array` є підпорядкований протоколу. Це можна зробити за допомогою порожнього розширення, що описано у підрозділі [Оголошення підпорядкування протоколу за допомогою розширення](20_protocols.md#Оголошення-підпорядкування-протоколу-за-допомогою-розширення):

```swift
extension Array: Container {}
```

Існуючі метод `append(_:)` та цілочисельний індекс дозволяють Swift визначити правильний тип для використання в якості асоційованого типу `Item`, так само, як і у випадку з узагальненим типом `Stack` вище. Після визначення цього розширення, будь-який масив можна використовувати як `Container`.

#### Додавання обмежень на асоційований тип

Можна додати обмеження типу на асоційований тип у протоколі, щоб вимагати у підпорядкованих типів задоволення цих обмежень. 

У протоколах обмеження типу на асоційовані типи додають для того, щоб вимагати у підпорядкованих типів задовольняти умови цих обмежень. Наприклад, у наступному прикладі оголошено версію протоколу `Container`, що вимагає, щоб елементи в контейнері підпорядковувались протоколу `Equatable`.

```swift
protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

Щоб підпорядковуватись даній версії протоколу `Container`, тип `Item` контейнера повинен підпорядковуватись протоколу `Equatable`.

#### Використання протоколів із обмеженнями асоційованих типів

Протокол може з'являтись як частина власних обмежень. Наприклад, ось протокол, що удосконалює протокол `Container`, додаючи до вимог метод `suffix(_:)`. Метод `suffix(_:)` повертає задану кількість елементів з кінця контейнера, зберігаючи їх у екземплярі типу `Suffix`.

```swift
protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
}
```

У цьому протоколі, `Suffix` є асоційованим типом, як і тип `Item` у протоколі `Container` у прикладах вище. Асоційований тип `Suffix` має два обмеження: він має підпорядковуватись протоколу `SuffixableContainer` (протоколу, що в даний момент оголошується), та його тип `Item` повинен співпадати із типом `Item` даного контейнера. Обмеження на `Item` задається за допомогою інструкції узагальнення where, що описана далі у підрозділі [Асоційовані типи із інструкцією узагальнення Where](#Асоційовані-типи-із-інструкцією-узагальнення-Where).

Ось розширення типу `Stack` із підрозділу [Узагальнені типи](#Узагальнені типи), котре підпорядковує його до протоколу `SuffixableContainer`:

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack {
        var result = Stack()
        for index in (count-size)..<count {
            result.append(self[index])
        }
        return result
    }
    // Тип Suffix визначено як Stack.
}
var stackOfInts = Stack<Int>()
stackOfInts.append(10)
stackOfInts.append(20)
stackOfInts.append(30)
let suffix = stackOfInts.suffix(2)
// suffix містить елементи 20 та 30
```

У прикладі вище, асоційованим типом `Suffix` для структури `Stack` є також `Stack`, таким чиином операція `suffix` на типі `Stack` повертає інший `Stack`. Однак, підпорядкований протоколу `SuffixableContainer` тип може мати `Suffix`, що на співпадає з цим же типом: іншими словами, операція `suffix` може повертати інший тип. Наприклад, ось розширення неузагальненого типу `IntStack`, що підпорядковує його протоколові `SuffixableContainer`, використовуючи тип `Stack<Int>` як тип `Suffix` замість типу `IntStack`:

```swift
extension IntStack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Int> {
        var result = Stack<Int>()
        for index in (count-size)..<count {
            result.append(self[index])
        }
        return result
    }
    // Тип Suffix визначено як Stack<Int>.
}
```

### Інструкція узагальнення Where

Обмеження типів, описані у підрозділі [Обмеження типів](#Обмеження-типів) вище, дозволяють визначати обмеження на параметри типу узагальнених функцій, індексів чи типів. 

Також буває потрібно визначати вимоги до асоційований типів. Це можна зробити за допомогою інструкції узагальнення where. Інструкція узагальнення where дозволяє вимагати, щоб асоційований тип підпорядковувався певному протоколу, або щоб певні параметри типів та асоційовані типи були однаковими. Інструкція узагальнення where починається з ключового слова `where`, після чого йдуть обмеження на асоційовані типи, чи відношення рівності між типами та асоційованими типами. Інструкції узагальнення where записуються прямо перед фігурною дужкою, з якої починається тіло типу чи функції. 

У прикладі нижче визначено узагальнену функцію, що називається `allItemsMatch`, котра перевіряє, чи співпадають елементи двох контейнерів, тобто чи містять два контейнери однакові елементи в одному й тому ж порядку. Дана функція повертає булеве значення `true`, якщо всі елементи співпадають, та `false`, якщо ні. 

Два контейнери, що перевіряються, не обов'язково повинні бути одного типу (хоч вони й можуть буту одного типу), але вони повинні містити елементи одного типу. Цю вимогу можна виразити за допомогою комбінації обмеження типів та інструкції узагальнення where:

```swift
func allItemsMatch<C1: Container, C2: Container>
    (_ someContainer: C1, _ anotherContainer: C2) -> Bool
    where C1.Item == C2.Item, C1.Item: Equatable {

        // Перевіряємо, що обидва контейнери містять однакову кількість елементів.
        if someContainer.count != anotherContainer.count {
            return false
        }
    
        // Перевіряємо пари елементів, щоб переконатись, що вони еквівалентні.
        for i in 0..<someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
             }
        }

        // Якщо всі елементи співпадають, повертаємо true.
        return true
}
```

Ця функція приймає два аргументи, що називаються `someContainer` та `anotherContainer`.  Аргумент `someContainer` має тип `C1`, а аргумент `anotherContainer` – `C2`. Як `C1`, так і `C2` є параметрами типу, що є типами-контейнерами, і конкретні їх типи будуть визначені під час виклику функції.

До двох параметрів типу даної функції виставляються наступні вимоги:

- `C1` має підпорядковуватись протоколу `Container` (записується як `C1: Container`).
- `C2` також має підпорядковуватись протоколу `Container` (записується як `C2: Container`).
- Тип `Item` для `C1` має співпадати із типом `Item` для C2 (записується як `C1.Item == C2.Item`).
- Тип `Item` для `C1` має підпорядковуватись протоколу `Equatable` (записується як `C1.Item: Equatable`).

Перша та друга вимоги оголошуються прямо у списку параметрів типу функції, а третя та четверта вимоги оголошуються у інструкції узагальнення where даної функції.

Ці вимоги означають, що:

- `someContainer` є контейнером типу `C1`.
- `anotherContainer` є контейнером типу `C2`.
- `someContainer` та `anotherContainer` містять елементи одного типу.
- Елементи у `someContainer` можна перевіртити на нерівність за допомогою оператору нерівності `!=`, щоб дізнатись, чи відрізняються вони один від одного.

Поєднання третьої та четвертої вимог означає, що елементи у `anotherContainer` *також* можна перевірити на нерівність за допомогою оператору `!=`, оскільки вони мають точно такий же тип, що і елементи у `someContainer`.

Ці вимоги дозволяють функції `allItemsMatch(_:_:)` порівнювати два контейнери, навіть якщо вони мають різний тип. 

Функція `allItemsMatch(_:_:)` розпочинається із перевірки, що обидва контейнери мають однакову кількість елементів. Якщо контейнери містять різну кількість елементів, вони ні в якому разі не можуть співпадати, і функція повертає `false`.

Після цієї перевірки, функція ітерує усі елементи у контейнері `someContainer` за допомогою циклу `for`-`in` та напіввідкритого оператору діапазону  (`..<`). Для кожного елемента, функція перевіряє, чи дорівнює елемент із `someContainer` його відповіднику із `anotherContainer`. Якщо два елементи не співпадають, тоді й два контейнери не співпадають, і функція повертає `false`.

Якщо цикл закінчується, не знайшовши неспівпадіння, тоді обидва контейнери співпадають, і функція повертає `true`. 

Ось як функція  `allItemsMatch(_:_:)` виглядає у дії:

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("bir")
stackOfStrings.push("eki")
stackOfStrings.push("üç")

var arrayOfStrings = ["bir", "eki", "üç"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("Всі елементи співпадають.")
} else {
    print("Не всі елементи співпадають.")
}
// Надрукує "Всі елементи співпадають."
```

У прикладі вище створено екземпляр `Stack`, що зберігає значення типу `String`, і в нього заштовхнуто три рядки. Далі у прикладі створено масив, що ініціалізовано літералом масиву, котрий містить ці ж само три рядки, що було заштовхнуто до стеку. Хоч `Stack` та `Array` - різні типи, вони обидва підпорядковуються протоколу `Container`, і обидва містять значення одного й того ж типу. Тому можна викликати функцію `allItemsMatch(_:_:)` із цими двома контейнерами в якості аргументів. У пиркладі вище, функція `allItemsMatch(_:_:)` коректно визначає, що всі елементи у цих двох контейнерах співпадають.

#### Extensions with a Generic Where Clause

#### Розшинення з інструкцією узагальнення Where

You can also use a generic `where` clause as part of an extension. The example below extends the generic Stack structure from the previous examples to add an isTop(_:) method.

```swift
extension Stack where Element: Equatable {
    func isTop(_ item: Element) -> Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}
```

This new `isTop(_:)` method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item. If you tried to do this without a generic where clause, you would have a problem: The implementation of isTop(_:) uses the == operator, but the definition of Stack doesn’t require its items to be equatable, so using the == operator results in a compile-time error. Using a generic where clause lets you add a new requirement to the extension, so that the extension adds the isTop(_:) method only when the items in the stack are equatable.

Here’s how the isTop(_:) method looks in action:

```swift
if stackOfStrings.isTop("tres") {
    print("Top element is tres.")
} else {
    print("Top element is something else.")
}
// Надрукує "Top element is tres.
```

If you try to call the isTop(_:) method on a stack whose elements aren’t equatable, you’ll get a compile-time error.

```swift
struct NotEquatable { }
var notEquatableStack = Stack<NotEquatable>()
let notEquatableValue = NotEquatable()
notEquatableStack.push(notEquatableValue)
notEquatableStack.isTop(notEquatableValue)  // Error
```

«You can use a generic where clause with extensions to a protocol. The example below extends the Container protocol from the previous examples to add a startsWith(_:) method.

```swift
extension Container where Item: Equatable {
    func startsWith(_ item: Item) -> Bool {
        return count >= 1 && self[0] == item
    }
}
```

The startsWith(_:) method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item. This new startsWith(_:) method can be used with any type that conforms to the Container protocol, including the stacks and arrays used above, as long as the container’s items are equatable.

```swift
if [9, 9, 9].startsWith(42) {
    print("Starts with 42.")
} else {
    print("Starts with something else.")
}
// Надрукує "Starts with something else."
```

The generic where clause in the example above requires Item to conform to a protocol, but you can also write a generic where clauses that require Item to be a specific type. For example:

```swift
extension Container where Item == Double {
    func average() -> Double {
        var sum = 0.0
        for index in 0..<count {
            sum += self[index]
        }
        return sum / Double(count)
    }
}
print([1260.0, 1200.0, 98.6, 37.0].average())
// Надрукує "648.9"
```

This example adds an average() method to containers whose Item type is Double. It iterates over the items in the container to add them up, and divides by the container’s count to compute the average. It explicitly converts the count from Int to Double to be able to do floating-point division.

You can include multiple requirements in a generic where clause that is part of an extension, just like you can for a generic where clause that you write elsewhere. Separate each requirement in the list with a comma.

### Associated Types with a Generic Where Clause

### Асоційовані типи із інструкцією узагальнення Where

You can include a generic where clause on an associated type. For example, suppose you want to make a version of Container that includes an iterator, like what the Sequence protocol uses in the standard library. Here’s how you write that:

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }

    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -> Iterator
}
```

The generic where clause on Iterator requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type. The `makeIterator()` function provides access to a container’s iterator.

For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic where clause in the protocol declaration. For example, the following code declares a ComparableContainer protocol that requires Item to conform to Comparable:

```swift
protocol ComparableContainer: Container where Item: Comparable { }
```

### Generic Subscripts

Subscripts can be generic, and they can include generic where clauses. You write the placeholder type name inside angle brackets after subscript, and you write a generic where clause right before the opening curly brace of the subscript’s body. For example:

```swift
extension Container {
    subscript<Indices: Sequence>(indices: Indices) -> [Item]
        where Indices.Iterator.Element == Int {
            var result = [Item]()
            for index in indices {
                result.append(self[index])
            }
            return result
    }
}
```

This extension to the Container protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index. This generic subscript is constrained as follows:

- The generic parameter Indices in angle brackets has to be a type that conforms to the Sequence protocol from the standard library.

- The subscript takes a single parameter, indices, which is an instance of that Indices type.
- The generic where clause requires that the iterator for the sequence must traverse over elements of type Int. This ensures that the indices in the sequence are the same type as the indices used for a container.

Taken together, these constraints mean that the value passed for the indices parameter is a sequence of integers.

