\#\#\# Кортежі

\*Кортежі\* групують кілька значень в єдине складене значення. Значення всередині кортежу можуть бути будь-якого типу і не обов'язково повинні мати однаковий тип.  



У наступному прикладі, \`\(404, "Not Found"\)\` є кортежем, що описує \*код стану\* HTTP. \[Код стану HTTP\]\(https://uk.wikipedia.org/wiki/Список\_кодів\_стану\_HTTP\) - це спеціальне значення, що повертається веб-сервером після кожного запиту веб-сторінки. Код стану \`404 Not Found\` повертається тоді, коли запитана сторінка не існує.



\`\`\`swift

let http404Error = \(404, "Не знайдено"\)

// http404Error має тип \(Int, String\), і дорівнює \(404, "Не знайдено"\)

\`\`\`



Кортеж \`\(404, "Not Found"\)\` групує разом значення типів \`Int\` та \`String\` щоб надати коду стану HTTP два окремих значення: число і зручний для сприйняття людиною опис. Його можна описати як “кортеж типу \`\(Int, String\)\`”.



Можна створити кортежі з будь-якої перестановки типів, і вони можуть містити скільки завгодно різних типів. Ніщо не заважає мати кортеж типу \`\(Int, Int, Int\)\` або \`\(String, Bool\)\`, або будь-яку іншу необхідну перестановку типів. 



Можна \*розкласти\* вміст кортежу на окремі константи чи змінні, до яких можна звертатись як звичайно:



\`\`\`swift

let \(statusCode, statusMessage\) = http404Error

print\("Код стану дорівнює \\(statusCode\)"\)

// Надрукує "Код стану дорівнює 404"

print\("Повідомлення статусу є \\(statusMessage\)"\)

// Надрукує "Повідомлення статусу є Не знайдено"

\`\`\`



Якщо потрібно тільки деякі зі значень кортежу, можна проігнорувати частини кортежу за допомогою символу підкреслення \(\`\_\`\) під час декомпозиції кортежу: 





\`\`\`swift

let \(justTheStatusCode, \_\) = http404Error

print\("Код статусу дорівнює \\(justTheStatusCode\)"\)

// Надрукує "Код статусу дорівнює 404"

\`\`\`





Іншим способом доступу до окремих елементів кортежу є числові індекси, які починаються з нульового: 

\`\`\`swift

print\("Код статусу дорівнює \\(http404Error.0\)"\)

// Надрукує "Код статусу дорівнює 404"

print\("Повідомлення статусу є \\(http404Error.1\)"\)

// Надрукує "Повідомлення статусу є Не знайдено"

\`\`\`



Також можна іменувати окремі елементи в кортежі під час його оголошення:



\`\`\`swift

let http200Status = \(statusCode: 200, description: "OK"\)

// Якщо елементи кортежу іменовані,

// можна користуватись їх іменами для доступу до їх значень:

print\("Код статусу дорівнює \\(http200Status.statusCode\)"\)

// Надрукує "Код статусу дорівнює 200"

print\("Повідомлення статусу є \\(http200Status.description\)"\)

// Надрукує "Повідомлення статусу є OK"

\`\`\`



Зокрема, кортежі зручні як значення, що повертають функції. Функція, що намагається отримати веб-сторінку, може повертати кортеж типу \`\(Int, String\)\`, щоб описати успіх чи невдачу при завантаженні сторінки. Повертаючи кортеж з двома окремими значеннями різних типів, функція надає більш корисну інформацію про свій результат, ніж якби вона повертала лише одне значення, чи кілька значень одного типу. З більш детальною інформацією можна ознайомитись у розділі \[Функції, що повертають кілька значень\]\(5\_functions.md\#функції,-що-повертають-кілька-значень\)



&gt; \*\*Примітка\*\*

&gt; 

&gt; Кортежі зручно вживати для тимчасових груп пов'язаних значень. Вони не підходять для створення складних структур даних. Якщо структура даних може жити поза тимчасовим контекстом, слід можелювати її за допомогою класу чи структури, а не кортежу. Більш детальну інформацію можна знайти у розділі \[Класи та структури\]\(1\_language\_guide/8\_classes\_and\_structures.md\).





\#\#\# Опціонали



\*Опціонали\* слід вживати, коли значення може бути відсутнє. Опціонали відображають дві можливості: або \*існує\* значення, і можна його розгорнути щоб отримати це значення, або \*не існує\* жодного значення. 



&gt; \*\*Примітка\*\*

&gt; 

&gt; Концепція опціоналів не існує у мовах C чи Objective-C. Найближчим поняттям у Objective-C є можливість повернути \`nil\` із методу, що зазвичай повертає об'єкт, в такому випадку \`nil\` означає "відсутність валідного об'єкту". Однак це працює лише з об'єктами, і не працює ні з структурами, ні з базовими типами мови C, ні з перечисленнями. Для таких типів методи Objective-C як правило повертають спеціальне значення \(таке як \`NSNotFound\`\) щоб позначити відсутність значення. Цей підхід базується на припущенні, що той, хто викликає метод, знає про це спеціальне значення, і пам'ятає, що слід його перевірити. Опціонали у мові Swift дозволяють вказувати на відсутність значення \*взагалі для будь-якого типу\*, без необхідності у спеціальних константах.





Ось приклад того як опціонали можуть бути використані щоб впоратись із відсутністю значення. Тип \`Int\` у Swift має ініціалізатор, що намагається конвертувати рядкове значення \`String\` у значення \`Int\`. Однак не кожний рядок можна конвертувати у ціле число. Рядок \`"123"\` можна конвертувати у числове значення \`123\`, але рядок \`"привіт, світ"\` не можна очевидним чином конвертувати у рядок.



У наступному прикладі ініціалізатор використовується для конвертації рядку \`String\` у число \`Int\`:



\`\`\`swift

let possibleNumber = "123"

let convertedNumber = Int\(possibleNumber\)

// тип convertedNumber визначено як "Int?", тобто "опціональний Int"

\`\`\`



Оскільки ініціалізатор може провалитись, він повертає опціональне значення  \`Int\`, замість простого \`Int\`. Опціональний тип \`Int\` пишеться як \`Int?\`, а не \`Int\`. Знак питання позначає те, що значення містить опціонал, і означає, що воно може містити \*деяке\* значення \`Int\`, або може не містити \*жодного значення взагалі\*. \(Воно не може містити будь-що інше, будь то значення типу \`Bool\` чи \`String\`. Воно може містити або \`Int\`, або нічого взагалі.\)



\#\#\#\# nil



Щоб опціональна змінна не містила жодного значення взагалі, слід присвоїти їй спеціальне значення \`nil\`:



\`\`\`swift

var serverResponseCode: Int? = 404

// serverResponseCode містить фактичне значення 404 типу Int

serverResponseCode = nil

// serverResponseCode тепер не містить жодного значення

\`\`\`



&gt; \*\*Примітка\*\*

&gt; 

&gt; \`nil\` не може вживатись із неопціональними константами та змінними. Якщо константа чи змінни в коді повинна опрацьовувати відсутність значення у деяких умовах, слід завжди оголошувати її як опціональне значення певного типу. 



Якщо оголосити опціональну змінну без зазначення значення за замовчуванням, змінна автоматично набуває значення \`nil\`:



\`\`\`swift

var surveyAnswer: String?

// surveyAnswer автоматично набуває значення nil

\`\`\`



&gt; \*\*Примітка\*\*

&gt; 

&gt; \`nil\` у Swift - це не те ж саме, що \`nil\` у Objective-C. У Objective-C, \`nil\` - це вказівник на неіснуючий об'єкт. У Swift, \`nil\` - це не вказівник, це відсутність значення певного типу. Опціонали \*будь-якого\* типу можуть набувати значення \`nil\`, а не лише опціонали об'єктних типів.



\#\#\#\# Інструкція If та Примусове розгортання



Щоб визначити, чи містить опціонал значення, можна вживати інструкцію \`if\`, порівнявши опціонал зі значенням \`nil\`. Цю операцію можна виконати за допомогою оператора “дорівнює” \(\`==\`\) або оператора “не дорівнює” \(\`!=\`\).



Якщо опціонал має значення, вважається що він "не дорівнює" \`nil\`:



\`\`\`swift

if convertedNumber != nil {

    print\("convertedNumber містить деяке цілочисельне значення."\)

}

// Надрукує "convertedNumber містить деяке цілочисельне значення."

\`\`\`



Як тільки ми впевнені, що опціонал \*містить\* значення, можна отримати це значення, додавши знак оклику \(\`!\`\) наприкінці імені опціоналу. Знак оклику фактично говорить "Я знаю, що цей опціонал точно має значення, будь-ласка, використовуйте його." Ця операція відома як \*примусове розгортання\* значення опціоналу: 



\`\`\`swift

if convertedNumber != nil {

    print\("convertedNumber має цілочисельне значення \\(convertedNumber!\)."\)

}

// Prints "convertedNumber має цілочисельне значення 123."

\`\`\`



Більш детально ознайомитись з інструкцією \`if\` можна в розділі \[Потік керування\]\(4\_control\_flow.md\).



&gt; \*\*Примітка\*\*

&gt; 

&gt; Спроба використати \`!\` для доступу до неіснуючого значення опціоналу призведе до помилки часу виконання. Перед тим, як вживати \`!\` для примусового розгортання значення опціоналу, слід упевнитись, що він містить не \`nil\`.





\#\#\#\# Опціональне зв'язування



Опціональне зв'язування вживається щоб дізнатись, чи містить опціонал значення, і якщо містить, зробити це значення доступним як тимчасова константа чи змінна. Опціональне зв'язування може вживатись з інструкціями \`if\` та \`while\` щоб перевірити опціонал на наявність значення, витягти це значення у константу чи змінну, і все це у вигляді єдиної дії. Інструкції \`if\` та \`while\` більш детально описані у розділі \[Потік керування\]\(4\_control\_flow.md\).



Синтаксис опціонального зв'язування для інструкції \`if\` виглядає наступним чином:



\`\`\`swift

if let &lt;ім'яКонстанти&gt; = &lt;якийсьОпціонал&gt; {

    &lt;інструкції&gt;

}

\`\`\`



Можна переписати приклад з \`possibleNumber\` із секції \[Опціонали\]\(\#опціонали\) використовуючи опціональне зв'язування замість примусового розгортання:



\`\`\`swift

if let actualNumber = Int\(possibleNumber\) {

    print\("\"\\(possibleNumber\)\" має цілочисельне значення \\(actualNumber\)"\)

} else {

    print\("\"\\(possibleNumber\)\" не можна конвертувати у ціле число"\)

}

// Надрукує ""123" має цілочисельне значення 123"

\`\`\`



Цей код можна прочитати так:



“Якщо опціональний \`Int\`, що повертається з \`Int\(possibleNumber\)\`, містить значення, створити нову константу з назвою \`actualNumber\` і ініціалізувати її значенням, що міститься в опціоналі.”



Якщо перетворення успішне, константа \`actualNumber\` стає доступною для використання всередині першої гілки інструкції \`if\`. Її вже було проініціалізовано значенням, що містилось \*всередині\* опціоналу, і тому непотрібно використовувати суфікс \`!\` для доступу до значення. У цьому прикладі  \`actualNumber\` просто використовується для друку результату перетворення. 



З опціональним зв'язуванням можна використовувати як константи, так і змінні. Якщо необхідно маніпулювати значенням \`actualNumber\` всередині першої гілки інструкції \`if\`, можна просто замість \`if let actualNumber\` написати \`if var actualNumber\`, і значення, що міститься всередині опціоналу стане доступною у вигляді змінної замість константи.



В єдину інструкцію \`if\` можна включити стільки опціональних зв'язувань і булевих умов, скільки потрібно, розділивши їх комами. Якщо будь-яке зі значень в опціональних зв'язуваннях є \`nil\`, або будь-яка булева умова виявиться хибною \(\`false\`\), вся умова інструкції \`if\` вважається хибною \(\`false\`\). Наступні інструкції \`if\` є еквівалентними:



\`\`\`swift

if let firstNumber = Int\("4"\), let secondNumber = Int\("42"\), firstNumber &lt; secondNumber && secondNumber &lt; 100 {

    print\("\\(firstNumber\) &lt; \\(secondNumber\) &lt; 100"\)

}

// Надрукує "4 &lt; 42 &lt; 100"



if let firstNumber = Int\("4"\) {

    if let secondNumber = Int\("42"\) {

        if firstNumber &lt; secondNumber && secondNumber &lt; 100 {

            print\("\\(firstNumber\) &lt; \\(secondNumber\) &lt; 100"\)

        }

    }

}

// Надрукує "4 &lt; 42 &lt; 100"

\`\`\`



&gt; \*\*Примітка\*\*

&gt; 

&gt; Константи і змінні, створені за допомогою опціонального зв'язування у інструкції \`if\` є доступними лише у тілі інструкції \`if\`. На відміну від цього, константи і змінні створені у інструкції \`guard\` є доступними у рядках коду, що слідують за інструкцією \`guard\`, як описано у розділі \[Ранній вихід\]\(4\_control\_flow.md\#ранній-вихід\).



\#\#\#\# Опціонали, що розгортаються неявно



Як описано вище, опціонали вказують на те, що константі чи змінній дозволяється "не мати значення". Опціонали можна перевірити за допомогою інструкції \`if\`, щоб побачити, чи існує значення, і можна розгорнути за допомогою опціонального зв'язування, щоб доступитись до значення опціоналу, якщо воно існує. 



Іноді зі структури програми ясно, що опціонал \*завжди\* має значення, після того як воно вперше задано. В таких випадках зручно позбутись необхідності перевіряти та розгортати значення опціоналу щоразу коли воно потрібно, бо можна безпечно припустити, що опціонал завжди має значення. 



Такі види опціоналів є \*опціоналами, що розгортаються неявно\*. Щоб створити опціонал, що розгортається неявно, слід додати знак оклику \(\`String!\`\) замість знаку питання \(\`String?\`\) після типу, котрий потрібно зробити опціональним.



Опціонали, що розгортаються неявно, зручно вживати коли існування значення опціоналу підтверджено одразу після оголошення, і можна точно припустити, що воно буде і надалі існувати. В основному опціонали, що розгортаються неявно, використовуються у мові Swift під час ініціалізації класів, як описано у розділі \[Чужинні посилання та опціонали, що розгортаються неявно\]\(23\_automatic\_reference\_counting.md\#безхазяйні-посилання-та-опціонали-що-розгортаються-неявно\).



За лаштунками опціонали, що розгортаються неявно, є звичайними опціоналами, але їх також можна використовувати як не опціональні значення, без необхідності кожного разу розгортати значення опціоналу. Наступний приклад демонструє різницю у поведінці між опціональним рядком та опціональним рядком, що розгортається неявно, під час доступу до їх внутрішнього значення типу \`String\`:



\`\`\`swift

let possibleString: String? = "Опціональний рядок."

let forcedString: String = possibleString! // потрібен знак оклику



let assumedString: String! = "Опціональний рядок, що розгортається неявно."

let implicitString: String = assumedString // не потрібен знак оклику

\`\`\`



Опціонали, що розгортаються неявно, можна розглядати як право опціоналу розгортатись автоматично там, де він використовується. Замість того, щоб писати знак оклику після імені опціоналу кожного разу, де він використовується, ми ставимо знак оклику після типу опціоналу під час оголошення. 



&gt; \*\*Примітка\*\*

&gt; 

&gt; Якщо опціонал, що розгортається неявно, дорівнює \`nil\`, під час спроби доступу до його значення відбудеться помилка часу виконання. Результат буде точно такий же як і при спробі поставити знак оклику після звичайного опціоналу, що не містить значення.



З опціоналом, що розгортається неявно, можна поводитись так само, як і зі звичайним опціоналом, зокрема, можна перевірити наявність значення:



\`\`\`swift

if assumedString != nil {

    print\(assumedString\)

}

// Надрукує "Опціональний рядок, що розгортається неявно."

\`\`\`



Також з опціоналами, що розгортаються неявно, можна застосовувати опціональне зв'язування, щоб перевірити та розгорнути значення однією інструкцією:



\`\`\`swift

if let definiteString = assumedString {

    print\(definiteString\)

}

// Prints "Опціональний рядок, що розгортається неявно."

\`\`\`



&gt; \*\*Примітка\*\*

&gt; 

&gt; Не слід використовувати опцінали, що розгортаються неявно, коли є можливість що змінна стане \`nil\` пізніше. Потрібно завжди використовувати звичайні опціональні типи, якщо потрібно перевіряти змінну на \`nil\` під час її життєвого циклу. 



\#\#\# Обробка помилок



\*Обробка помилок\* - це механізм, що дозволяє відповідати помилковим умовам, з якими може зіткнутись програми під час виконання. 



Опціонали присутністю або відсутністю значення можуть повідомляти про успіх чи невдачу у функції. На відміну від них, обробка помилок дозволяє визначити причину невдачі, і, якщо потрібно, поширити цю помилку до інших частин програми. 



Коли функція стикається із помилковими умовами, вона \*викидає\* помилку. Викликач цієї функції може \*перехопити\* помилку і відповідним чином прореагувати. 



\`\`\`swift

func canThrowAnError\(\) throws {

    // ця функція може або викинути помилку, або відпрацювати успішно.

}

\`\`\`



Функції повідомляють про можливість викинути помилку за допомогою ключового слова  \`throws\` в оголошенні. Викликаючи функцію, що може викинути помилку, слід додавати ключове слово \`try\` перед її іменем.



У мові Swift помилки автоматично поширюються назовні від їх поточного контексту до тих пір, поки вони не будуть оброблені у блоці \`catch\`.



\`\`\`swift

do {

    try canThrowAnError\(\)

    // помилку не викинуто

} catch {

    // помилку викинуто

}

\`\`\`



Інструкція \`do\` створює новий контекст, що дозволяє помилкам бути поширеними до одного чи кількох блоків \`catch\`.



Ось приклад того, як обробка помилок може бути використаною, щоб відповідати до різних помилкових умов:



\`\`\`swift

func makeASandwich\(\) throws {

    // ...

}



do {

    try makeASandwich\(\)

    eatASandwich\(\)

} catch SandwichError.outOfCleanDishes {

    washDishes\(\)

} catch SandwichError.missingIngredients\(let ingredients\) {

    buyGroceries\(ingredients\)

}

\`\`\`



У даному прикладі, функція \`makeASandwich\(\)\` \("зробити сендвіч"\) викине помилку, якщо немає чистих тарілок, або якщо не вистачає певних інгредієнтів. Оскільки функція \`makeASandwich\(\)\` може викинути помилку, виклик функції обгорнуто у вираз \`try\`. При огортанні виклику функції в блок інструкції \`do\`, будь-які помилки, викинуті цією функцією, будуть передані до прописаних нижче блоків \`catch\`.



Якщо не викинуто жодної помилки, буде викликано функцію \`eatASandwich\(\)\` \(з'їсти сендвіч\). Якщо викинуто помилку, і вона відповідає випадку \`SandwichError.outOfCleanDishes\`, тоді буде викликано функцію \`washDishes\(\)\`. 

Якщо викинуто помилку, і вона відповідає випадку \`SandwichError.missingIngredients\`, тоді буде викликано функцію \`buyGroceries\(\_:\)\` з асоційованим значенням \`\[String\]\`, захопленим за допомогою патерну \`catch\`. Викидання, перехоплення і передача помилок розкрито біль детально у розділі \[Обробка помилок\]\(16\_error\_handling.md\).



\#\#\# Припущення



У деяких випадках неможливо продовжити виконання коду, якщо не виконуються певні умови. У таких випадках слід викликати \*припущення\* у коді, щоб завершити виконання коду, та надати можливість дослідити причину невиконання умови. 



\#\#\#\# \[Зневадження\] з припущеннями



Припущення - це перевірка часу виконання, що булева умова точно виконується як \`true\`. Буквально, припущення "припускає", що умова є \`true\`. Слід вживати припущення, щоб упевнитись, що важлива умова буде задоволена до виконання подальшого коду. Якщо умова є \`true\`, виконання коду продовжується як звичайно; якщо умова є \`false\`, виконання коду припиняється, а програма завершується.



Якщо код викликає припущення під час виконання у \[зневаджувальному\] середовищі, як, наприклад, під час побудови та запуску програми у Xcode, можна бачити точне місце, де було досягнуто хибного стану, і запросити стан програми під час виклику припущення. Припущення також дають можливість надати доречне \[зневаджувальне\] повідомлення, що пояснить причину припущення.



Щоб написати припущення, треба викликати функцію стандартної бібліотеки Swift  \`assert\(\_:\_:file:line:\)\`. Слід передати в цю функцію вираз, що обчислиться як \`true\` або \`false\`, та повідомлення, що слід відобразити у випадку, якщо результат умови буде \`false\`:



\`\`\`swift

let age = -3

assert\(age &gt;= 0, "Вік особи не може бути меншим від нуля"\)

// це призведе до виклику припущення, бо вік не &gt;= 0

\`\`\`



У даному прикладі, виконання коду продовжиться тільки якщо \`age &gt;= 0\` обчислиться як \`true\`, тобто якщо значення віку \`age\` невід'ємне. Якщо значення  \`age\` від'ємне, як у коді вище, тоді \`age &gt;= 0\` обчислиться як \`false\`, і припущення буде викликано, завершуючи програму.



Повідомлення у припущенні може бути пропущене, якщо потрібно, як у наступному прикладі:



\`\`\`swift

assert\(age &gt;= 0\)

\`\`\`



&gt; \*\*Примітка\*\*

&gt; 

&gt; Припущення відключаються, якщо код скомпільовано з оптимізаціями, як наприклад під час побудови програми у конфігурації Release за замовчуванням у Xcode.



\#\#\#\# Коли слід вживати припущення



Слід вживати припущення завжди коли існує можливість, що умова може бути \`false\`, але при цьому умова має \*точно\* бути \`true\` для того, щоб код продовжив виконання. Доречні сценарії для перевірок припущень включають:



 + Цілочисельний індекс передано до власної реалізації оператору індексу, але значення індексу може бути занадто мале чи занадто велике.

 + Значення передано функції, але при деяких значеннях функція не може виконати своє завдання. 

 + Опціональне значення наразі \`nil\`, коду для успішного виконання потрібно значення, що не дорівнює \`nil\`. 



Дивіться також \[Індекси\]\(11\_subscripts.md\) та \[Функції\]\(5\_functions.md\).  



&gt; \*\*Примітка\*\*

&gt; 

&gt; Припущення призводять до термінового завершення програми, вони не підходять для проектування коду в такий спосіб, що невалідні умови наврядчи трапляться. Тим не менше, у ситуаціях, коли невалідні умови можливі, припущення - це ефективний спосіб впевнитись, що такі умови виділені і помічені під час розробки, до часу публікації програми. 



