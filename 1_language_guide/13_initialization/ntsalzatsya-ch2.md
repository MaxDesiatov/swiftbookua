#### Автоматичне наслідування ініціалізаторів

Як зазначено вище, класи-нащадки не успадковують ініціалізатори своїх базових класів за замовчанням. Однак, ініціалізатори батьківських класів автоматично наслідуються за певних умов. На практиці, це означає, що вам не потрібно писати заміщення ініціалізаторів у багатьох загальних сценаріях; ініціалізатори батьківських класів можуть бути успадкованими з мінімальними зусиллями завжди, коли це безпечно.

Якщо всі нові властивості, що оголошуються у класах нащадках, мають значення за замовчанням, працюють наступні два правила:  
Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:

**Правило 1**

```
  Якщо клас-нащадок не визначає нових призначених ініціалізаторів, він автоматично успадковує усі призначені ініціалізатори батьківського класу.
```

**Правило 2**

```
  Якщо клас-нащадок має реалізації _усім_ призначеним ініціалізаторам батьківського класу – як шляхом їх наслідування за правилом 1, так і шляхом власної їх реалізації – тоді він автоматично успадковує всі ініціалізатори для зручності батьківського класу.
```

Ці правила працюють в тому числі й тоді, коли клас-нащадок оголошує додаткові ініціалізатори для зручності.

> **Примітка**
>
> Клас-нащадок може реалізувати призначений ініціалізатор батьківського класу як ініціалізатор для зручності, і таким чимон задовольнити правило 2.

#### Призначені ініціалізатори та ініціалізатори для зручності в дії

Наступний приклад демонструє призначені ініціалізатори, ініціалізатори для зручності та автоматичне наслідування ініціалізаторів у дії. Цей приклад визначає ієрархію з трьох класів: `Food`, `RecipeIngredient`, та `ShoppingListItem`, і демонструє взаємодію їх ініціалізаторів.

Базовий клас в ієрархії називається `Food` \(Їжа\), він є простим класом для інкапсуляції імені харчового продукту. Клас `Food` вводить єдину властивість типу `String` на ім'я `name`, і має два ініціалізатори для створення екземплярів `Food`:

```swift
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Без імені]")
    }
}
```

Зображення нижче демонструє ланцюжок ініціалізаторів класу `Food`:

![](images/initializersExample01_2x.png)  
￼  
Класи не мають почленних ініціалізаторів за замовчанням, і тому в класі `Food` явно міститься призначений ініціалізатор, що приймає єдиний аргумент на ім'я `name`. Цей ініціалізатор може використовуватись для створення нового екземпляру класу `Food` із певним іменем:

```swift
let namedMeat = Food(name: "Салечко")
// ім'я namedMeat – "Салечко"
```

Ініціалізатор `init(name: String)` класу `Food` визначено як  _призначений_ ініціалізатор, бо він впевнюється в тому, що всі властивості, що зберігаються в новому екземплярі класу `Food`  було проініціалізовано. Клас `Food` не має батьківського класу, і тому ініціалізатор `init(name: String)` не повинен викликати `super.init()` для завершення ініціалізації.

Клас `Food` також має ініціалізатор _для зручності_, `init()`, без аргументів. Ініціалізатор `init()` надає тимчасове ім'я за замовчанням новим екземплярам класу `Food`, делегуючи ініціалізацію до ініціалізатора `init(name: String)`, зі значенням аргументу `name` – `"[Без імені]"`:

```swift
let mysteryMeat = Food()
// ім'я mysteryMeat – "[Без імені]"
```

Другим класом в ієрархії є нащадок класу `Food` на ім'я `RecipeIngredient`. Клас `RecipeIngredient` моделює інгредієнт у кухонному рецепті. Він додає властивість типу `Int` на ім'я `quantity`, що виражає кількість продукту \(на додачу до властивості `name`, що вже успадкована з класу `Food`\). Він також має два ініціалізатори для створення екземплярів `RecipeIngredient`:

```swift
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
```

Зображення нижче демонструє ланцюжок ініціалізаторів класу `RecipeIngredient`:

![](images/initializersExample02_2x.png)  
￼  
Клас `RecipeIngredient` має один призначений ініціалізатор, `init(name: String, quantity: Int)`, котрий можна використовувати для заповнення всіх властивостей нового екземпляру `RecipeIngredient` значеннями. Цей ініціалізатор починається із присвоєння значення переданого аргументу `quantity` до однойменної властивості, котра є єдиною новою властивістю, введеною класом `RecipeIngredient`. Після цього, ініціалізатор делегує ініціалізацію до ініціалізатора `init(name: String)` класу `Food`. Цей процес задовольняє перевірку безпеки 1 з підрозділу [Двофазна ініціалізація](13_initialization.md#Двофазна-ініціалізація) вище.

Клас `RecipeIngredient` також має ініціалізатор для зручності, `init(name: String)`, котрий можна використовувати для створення екземплярів `RecipeIngredient` лише за іменем. Цей ініціалізатор для зручності припускає, що кількість інгредієнту дорівнює `1` для будь-якого екземпляру `RecipeIngredient`, що створюється без явного вказування кількості. Визначення ініціалізатора для зручності робить створення екземплярів `RecipeIngredient` швидшим та зручнішим, та запобігає дублюванню коду при створенні кількох екземплярів `RecipeIngredient` з кількістю `1`. Цей ініціалізатор просто делегує ініціалізацію призначеному ініціалізатору даного класу, передаючи `1` як значення `quantity`.

Ініціалізатор для зручності `init(name: String)` класу `RecipeIngredient` приймає такі ж аргументи, як і _призначений_  ініціалізатор класу `Food`. Оскільки цей ініціалізатор для зручності заміщує призначений ініціалізатор батьківського класу, він повинен позначатись ключовим словом `override` \(як описано у підрозділі [Наслідування ініціалізаторів та їх заміщення](13_initialization.md#Наслідування-ініціалізаторів-та-їх-заміщення)\).

Хоч клас `RecipeIngredient` реалізовує ініціалізатор `init(name: String)` як ініціалізатор для зручності, цей клас тим не менш реалізовує всі призначені ініціалізатори батьківського класу. Таким чином, клас `RecipeIngredient` автоматично отримує всі ініціалізатори для зручності свого батьківського класу.

У даному прикладі, батьківським класом класу `RecipeIngredient` є клас `Food`, котрий має єдиний ініціалізатор для зручності на ім'я `init()`. Цей ініціалізатор успадковується класом `RecipeIngredient`. Успадкована версія ініціалізатора `init()` працює точно так само як і в класі `Food`, крім того, що вона делегує ініціалізацію до версії ініціалізатора `init(name: String)` класу  `RecipeIngredient`, а не класу `Food`.

Усі три ці ініціалізатори можна використовувати для створення нових екземплярів класу `RecipeIngredient`:

```swift
let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Салечко")
let sixEggs = RecipeIngredient(name: "Яйця", quantity: 6)
```

Третім та останнім класом в ієрархії є нащадок класу `RecipeIngredient` на ім'я `ShoppingListItem`. Клас `ShoppingListItem` моделює інгредієнт рецепту при його появі в списку покупок.

Кожен елемент у списку покупок спершу є “не купленим”. Щоб відобразити цей факт, клас `ShoppingListItem` вводить булеву властивість на ім'я `purchased`, зі значенням за замовчанням `false`. Клас `ShoppingListItem` також вводить властивість, що обчислюється `description`, котра генерує текстовий опис екземпляру `ShoppingListItem`:

```swift
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
```

> **Примітка**
>
> Клас `ShoppingListItem` не визначає ініціалізатора для задавання початкового значення властивості `purchased`, оскільки усі елементи у списку покупок спершу не є купленими.

Оскільки клас `ShoppingListItem` задає значення за замовчанням усім властивостям, які він вводить, і не визначає жодних власних ініціалізаторі, він автоматично успадковує _усі_ призначені ініціалізатори та ініціалізатори для зручності від свого батьківського класу.

Зображення нижче демонструє повний ланцюжок ініціалізаторів усіх трьох класів:

![](images/initializersExample03_2x.png)  
￼  
Для створення нових екземплярів класу `ShoppingListItem` можна використовувати усі три успадковані ініціалізатори:

```swift
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Салечко"),
    ShoppingListItem(name: "Яйця", quantity: 6),
]
breakfastList[0].name = "Апельсиновий сік"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x Апельсиновий сік ✔
// 1 x Салечко ✘
// 6 x Яйця ✘
```

Тут у прикладі вище з літерала масиву, що містить три нові екземпляри класу `ShoppingListItem`, створюється масив на ім'я `breakfastList`. Тип даного масиву визначено як `[ShoppingListItem]`. Після створення масиву, назву першого в масиві екземпляру `ShoppingListItem` змінено з `"[Без імені]"` на `"Апельсиновий сік"`, а потім цей екземпляр помічається як куплений. Далі слідує друк описів кожного елементу з масиву, що демонструє  те, що задавання початкових станів відбулось так, як очікувалось.

### Ненадійні ініціалізатори

Іноді буває корисним мати клас, структуру чи перечислення, чия ініціалізація може провалитись. Цей провал може бути спричиненим некоректними значеннями параметрів ініціалізації, відсутністю необхідного зовнішнього ресурсу, або іншою умовою, що перешкоджає успішній ініціалізації.

Щоб впоратись з умовами ініціалізації, що призводять до її провалу, слід визначити один або декілька ненадійних ініціалізаторів в оголошенні класу, структури чи перечислення. Ненадійні ініціалізатори записуються за допомогою додавання знаку питання після ключового слова `init` \(`init?`\).

> **Примітка**
>
> Не можна оголошувати одночасно звичайний та ненадійний ініціалізатори з однаковими типами параметрів та їх іменами.

Ненадійний ініціалізатор створює _опціональне_ значення типу, котрий ініціалізується. Щоб відобразити момент провалу ініціалізації, слід писати `return nil` всередині ненадійного ініціалізатора.

> **Примітка**
>
> Строго кажучи, ініціалізатори не повертають значення. Натомість їхня роль полягає у тому, щоб упевнитись, що `self` є повністю та коректно проініціалізовано до моменту завершення ініціалізації. Хоча провали ініціалізаці й записуються як `return nil`, не потрібно писати ключове слово `return` для позначення успішного завершення ініціалізації.

У прикладі нижче визначено структуру `Animal` \(що моделює тварину\), із константною властивістю типу `String` на ім'я `species` \(що моделює її вид\). У структурі `Animal` також визначено ненадійний ініціалізатор з єдиним параметром на ім'я `species`. Цей ініціалізатор перевіряє передане значення параметру `species`: якщо це порожній рядок, генерується провал ініціалізації. В іншому випадку, значення присвоюється властивості `species`, та ініціалізація завершується вдало:

```swift
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
```

Тепер можна скористатись ненадійним ініціалізатором, щоб спробувати створити новий екземпляр `Animal` та перевірити, чи була ініціалізація успішною:

```swift
let someCreature = Animal(species: "Жирафа")
// someCreature має тип Animal?, не Animal

if let giraffe = someCreature {
    print("Тварина було ініціалізовани з видом \(giraffe.species)")
}
// Надрукує "Тварина було ініціалізовани з видом Жирафа"
```

Якщо передати порожній рядок як параметр `species` ненадійного ініціалізатора, це спровокує провал ініціалізації:

```swift
let anonymousCreature = Animal(species: "")
// anonymousCreature має тип Animal?, не Animal

if anonymousCreature == nil {
    print("Неможливо ініціалізувати анонімне створіння")
}
// Надрукує "Неможливо ініціалізувати анонімне створіння"
```

> **Примітка**
>
> Перевірка рядка на порожність \(наприклад, `""` замістю `"Жирафа"`\) – це не те ж саме, що перевірка на `nil` для визначення відсутності значення _опціонального_ значення типу `String`. У прикладі вище, порожній рядок \(`""`\) є дійсним, неопціональним значенням типу `String`. Однак, для трарини мати порожній рядок в якості властивості `species` \(вид\) є недоречним. Щоб змоделювати це обмеження, ненадійний ініціалізатор провалює ініціалізацію у випадку виявлення порожнього рядка.

#### Ненадійні ініціалізатори в перечисленнях

Ненадійними ініціалізаторами зручно користуватись, щоб обрати відповідний елемент перечислення, базуючись на одному або кількох параметрах. Ініціалізатор може провалитись, якщо заданим параметрам не відповідає жоден з елементів перечислення.

У прикладі нижче визначено перечислення `TemperatureUnit`, котре моделює одиницю вимірювання температури та має три елементи \(`kelvin`, `celsius`, та `fahrenheit`\). Ненадійний ініціалізатор використовується для знаходження елементу перечислення за значенням типу `Character`, що представляє символ температури відповідної шкали:

```swift
enum TemperatureUnit {
    case kelvin, celsius, fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .kelvin
        case "C":
            self = .celsius
        case "F":
            self = .fahrenheit
        default:
            return nil
        }
    }
}
```

Можна використовувати цей ненадійний ініціалізатор для того, щоб обрати відповідний елемент перечислення, або провалитись, якщо параметр не відповідає жодному з елементів перечислення:

```swift
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("Це відома шкала температури, тому ініціалізація була успішною.")
}
// Надрукує "Це відома шкала температури, тому ініціалізація була успішною."

let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("Це невідома шкала температури, тому ініціалізація провалилась.")
}
// Надрукує "Це невідома шкала температури, тому ініціалізація провалилась."
```

#### Ненадійні ініціалізатори в перечисленнях з сирими значеннями

Перечислення із сирими значеннями автоматично отримують ненадійний ініціалізатор, `init?(rawValue:)`, котрий приймає параметр на ім'я `rawValue` відповідного типу сирого значення, та обирає відповідний елемент перечислення по сирому значенню, або провалюється у випадку, якщо не існує відповідного елементу.

Можна переписати приклад з перечисленням `TemperatureUnit` вище, використовуючи сирі значенням типу `Character` та скориставшись перевагами ініціалізатора `init?(rawValue:)`:

```swift
enum TemperatureUnit: Character {
    case kelvin = "K", celsius = "C", fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("Це відома шкала температури, тому ініціалізація була успішною.")
}
// Надрукує "Це відома шкала температури, тому ініціалізація була успішною."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("Це невідома шкала температури, тому ініціалізація провалилась.")
}
// Надрукує "Це невідома шкала температури, тому ініціалізація провалилась."
```

#### Поширення провалу ініціалізації

Ненадійний ініціалізатор класу, структури чи перечислення може делегувати ініціалізацію до іншого ненадійного ініціалізатора цього ж класу, структури чи перечислення. Аналогічно, ненадійний ініціалізатор класу-нащадка може делегувати ініціалізацію до ненадійного ініціалізатора батьківського класу.

В будь-якому випадку, якщо відбувається делегування ініціалізатору, в котрому ініціалізація провалюється, весь процес ініціалізації одразу провалюється, і жоден подальший код ініціалізації не виконується.

> **Примітка**
>
> Ненадійний ініціалізатор також може делегувати ініціалізацію до звичайного ініціалізатора. Слід користуватись таким підоходом для того, щоб розширити процес ініціалізації, що не провалюється, додатковою обробкою провалів.

У прикладі нижче оголошено клас-нащадок класу  `Product`, що називається `CartItem`. Клас `CartItem` моделює елемент в кошику інтернет-магазину. `CartItem` додає константну властивість, що зберігається, на ім'я `quantity`, та має ненадійний ініціалізатор, що контролює, що ця властивість завжди має значення не менше за `1`:

```swift
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}

class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
```

Ненадійний ініціалізатор класу `CartItem` розпочинається з валідації аргументу `quantity`. Якщо значення `quantity` менше за `1`, тобто не валідне, весь процес ініціалізації одразу провалюється і подальший код ініціалізації не виконується. Аналогічно, ненадійний ініціалізатор класу `Product` перевіряє значення `name`, і якщо це порожній рядок – процес ініціалізації одразу провалиться.

Якщо створити екземпляр `CartItem` із непорожньою назвою та кількістю `1` або більше, процес ініціалізації завершується успішно:

```swift
if let twoSocks = CartItem(name: "шкарпетка", quantity: 2) {
    print("Товар: \(twoSocks.name), кількість: \(twoSocks.quantity)")
}
// Надрукує "Товар: шкарпетка, кількість: 2"
```

Якщо створити екземпляр класу `CartItem` зі значенням  `quantity`, що дорівнює `0`, ініціалізатор `CartItem` провалить ініціалізацію:

```swift
if let zeroShirts = CartItem(name: "сорочка", quantity: 0) {
    print("Товар: \(zeroShirts.name), кількість: \(zeroShirts.quantity)")
} else {
    print("Неможливо ініціалізувати нуль сорочок")
}
// Надрукує "Неможливо ініціалізувати нуль сорочок"
```

Аналогічно, якщо спробувати створити екземпляр класу `CartItem` з порожнім значенням `name`, ініціалізатор батьківського класу `Product` провалить ініціалізацію:

```swift
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Товар: \(oneUnnamed.name), кількість: \(oneUnnamed.quantity)")
} else {
    print("Неможливо ініціалізувати безіменний товар")
}
// Надрукує "Неможливо ініціалізувати безіменний товар"
```

#### Заміщення ненадійних ініціалізаторів

Ненадійні ініціалізатори батьківських класів можна заміщувати в класах-нащадках, як і будь-які інші ініціалізатори. Також можливо замістити ненадійний ініціалізатор батьківського класу _надійним_ ініціалізатором класу-нащадка. Це дає можливість створювати класи-нащадки, чия ініціалізація не провалюється, хоч ініціалізація батьківського класу і може при цьому провалюватись.

Слід помітити, що коли заміщується ненадійний ініціалізатор батьківського класу надійним ініціалізатором класу-нащадка, єдиним способом делегувати ініціалізацію до батьківського класу є примусове розгортання результату виклику ненадійного ініціалізатора батьківського класу.

> **Примітка**
>
> Можна замістити ненадійний ініціалізатор надійним, але не можна зробити навпаки.

У прикладі нижче оголошено клас на ім'я `Document`. Цей клас моделює документ, котрий може бути ініціалізованим властивістю `name`, котра має бути або непорожнім рядком, або `nil`, однак не може бути порожнім рядком:

```swift
class Document {
    var name: String?
    // цей ініціалізатор створює документ зі значенням name nil
    init() {}
    // цей ініціалізатор створює документ із непорожнім значенням name
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
```

У наступному прикладі оголошено клас-нащадок класу `Document` на ім'я `AutomaticallyNamedDocument`. Клас-нащадок `AutomaticallyNamedDocument` заміщує обидва призначених ініціалізатори, введених класом `Document`. Ці заміщення гарантують, що екземпляр класу `AutomaticallyNamedDocument` матиме початкове значення `name` `"[Безіменний]"` у випадках, якщо він ініціалізується без назви, або якщо до ініціалізатора `init(name:)` передано порожній рядок:

```swift
class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Безіменний]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Безіменний]"
        } else {
            self.name = name
        }
    }
}
```

Клас `AutomaticallyNamedDocument` заміщує ненадійний ініціалізатор батьківського класу `init?(name:)` надійним ініціалізатором `init(name:)`. Оскільки клас `AutomaticallyNamedDocument` справляється з випадком порожнього рядка іншим способом, аніж його батьківський клас, його ініціалізатору не потрібно провалюватись, і тому даний клас натомість містить надійну версію даного ініціалізатора.

В реалізації надійного ініціалізатора класу-нащадка можна використовувати примусове розгортання виклику ненадійного ініціалізатора батьківського класу. Наприклад, клас-нащадок `UntitledDocument` у прикладі нижче завжди має назву `"[Безіменний]"`, і використовує під час ініціалізації ненадійний ініціалізатор батьківського класу `init(name:)`:

```swift
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Безіменний]")!
    }
}
```

В даному випадку, якби ініціалізатор `init(name:)` батьківського класу був викликаний з порожнім рядком в якості параметра `name`, операція примусового розгортання призвела б до помилки часу виконання. Однак, оскільки в якості параметра завжди передається рядкова константа, даний ініціалізатор не може провалитись і в даному випадку не буде помилки часу виконання.

#### Ненадійний ініціалізатор init!

Як привило, ненадійні ініціалізатори оголошують за допомогою знаку питання після ключового слова `init` \(`init?`\), і такі ініціалізатори створюють опціональний екземпляр відповідного типу. Однак, також можна оголошувати ненадійні ініціалізатори, котрі повертають опціональні екземпляри відповідного типу, що розгортаються неявно. Такі ініціалізатори записуються за допомогою знаку оклику після ключового слова `init` \(`init!`\) замість знаку питання.

Можна делегувати ініціалізацію з ініціалізатора `init?` до `init!` і навпаки, а також можна заміщувати ініціалізатор `init?` ініціалізатором `init!` і навпаки. Також можна делегувати з ініціалізатора `init` до `init!`, однак це спричинить помилку часу виконання у випадку, якщо ініціалізатор `init!` спровокує провал ініціалізації.

### Обов'язкові ініціалізатори

Якщо перед оголошенням ініціалізатору класу вказати ключове слово `required`, усі нащадки даного класу повинні будуть реалізовувати даний ініціалізатор:

```swift
class SomeClass {
    required init() {
        // ініціалізація буде проходити тут
    }
}
```

Також обов'язково слід вказувати модифікатор `required` перед кожною реалізацією обов'язкового ініціалізатора в класі-нащадку, щоб позначити, що обов'язковість даного ініціалізатора стосується також подальших нащадків у ланцюжку. Перед обов'язковим заміщенням призначеного ініціалізатора при цьому не обов'язково вказувати ключове слово `override`:

```swift
class SomeSubclass: SomeClass {
    required init() {
        // реалізація обов'язкового ініціалізатора класу-нащада буде проходити тут
    }
}
```

> **Примітка**
>
> Не обов'язково надавати явну реалізацію обов'язкового ініціалізатора, якщо можна делегувати ініціалізацію успадкованому ініціалізатору.

### Присвоєння початкового значення за допомогою замикання чи функції

Якщо початкове значення властивості, що зберігається, потребує якогось налаштування, для генерації такого початкового значення можна використати замикання чи глобальну функцію. При ініціалізації нового екземпляру типу, до якого належить властивість, буде викликано замикання чи функція, і її значення, що повертається, буде присвоєно властивості як початкове значення.

Ці види замикань чи функцій, як правило, створюють тимчасове значення того ж типу, що й властивість, конфігурують його до бажаного початкового стану, а потім повертають це тимчасове значення для використання як початкове значення властивості.

Ось приблизний шаблон використання замикання для створення початкового значення властивості:

```swift
class SomeClass {
    let someProperty: SomeType = {
        // Значення за замовчанням властивості someProperty
        // створюється в цьому замиканні.
        // someValue повинно мати тип SomeType.
        return someValue
    }()
}
```

Слід помітити, що одразу за фігурними дужками замикання йде порожня пара круглих дужок. Це вказує Swift виконати замикання одразу після його оголошення. Якщо пропустити ці круглі дужки, властивості буде присвоюватись саме замикання, а не значення, яке повертає замикання.

> **Примітка**
>
> При використанні замикань для ініціалізації властивостей, слід пам'ятати, що решта екземпляру ще не було ініціалізовано на момент виконання замикання. Це означає, що не можна звертатись до інших властивостей з цього замикання, навіть якщо вони мають значення за за мовчанням. Також не можна використовувати неявну властивість `self`, чи викликати будь-які методи екземпляру.

У прикладі нижче оголошено структуру з назвою `Chessboard`, котра моделює дошку для гри в шахи. В шахи грають на дошці розміром 8 x 8 клітинок, котрі почергово зафарбовані в білий та чорний.

![](images/chessBoard_2x.png)  
￼

Щоб представити дану ігрову дошку, структура  `Chessboard` має одну властивість на ім'я `boardColors`, котра є масивом з 64 булевих значень. Значення `true` в цьому масиві представляє чорну клітинку, а значення `false` – білу клітинку. Перший елемент в масиві представляє верхню ліву клітинку на дошці, а останній елемент в масиві – нижню праву.

Масив `boardColors` ініціалізується за допомогою замикання для налаштування значень кольорів клітинок:

```swift
struct Chessboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...8 {
            for j in 1...8 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
    }()
    func squareIsBlackAt(row: Int, column: Int) -> Bool {
        return boardColors[(row * 8) + column]
    }
}
```

Щоразу при створенні екземпляру `Chessboard`, буде виконуватись замикання, котре обчислюватиме й повертатиме початкове значення властивості `boardColors`. Дане замикання у прикладі вище обчислює та присвоює відповідний колір кожній клітинці на дошці в тимчасово створеному масиві `temporaryBoard`, і повертає цей тимчасовий масив після завершення налаштування. Масив, що повертається, буде збережено у властивості `boardColors` та потім до нього можна звертатись у допоміжній функції `squareIsBlackAtRow`, котра перевіряє колір клітинки за індексами:

```swift
let board = Chessboard()
print(board.squareIsBlackAt(row: 0, column: 1))
// Надрукує "true"
print(board.squareIsBlackAt(row: 7, column: 7))
// Надрукує "false"
```



